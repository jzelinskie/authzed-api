// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file authzed/api/materialize/v0/watchpermissionsets.proto (package authzed.api.materialize.v0, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { ZedToken } from "../../v1/core_pb.js";

/**
 * @generated from message authzed.api.materialize.v0.WatchPermissionSetsRequest
 */
export class WatchPermissionSetsRequest extends Message<WatchPermissionSetsRequest> {
  /**
   * optional_starting_after is used to specify the SpiceDB revision to start watching from.
   * If not specified, the watch will start from the current SpiceDB revision time of the request ("head revision").
   *
   * @generated from field: authzed.api.v1.ZedToken optional_starting_after = 1;
   */
  optionalStartingAfter?: ZedToken;

  constructor(data?: PartialMessage<WatchPermissionSetsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.WatchPermissionSetsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "optional_starting_after", kind: "message", T: ZedToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WatchPermissionSetsRequest {
    return new WatchPermissionSetsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WatchPermissionSetsRequest {
    return new WatchPermissionSetsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WatchPermissionSetsRequest {
    return new WatchPermissionSetsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WatchPermissionSetsRequest | PlainMessage<WatchPermissionSetsRequest> | undefined, b: WatchPermissionSetsRequest | PlainMessage<WatchPermissionSetsRequest> | undefined): boolean {
    return proto3.util.equals(WatchPermissionSetsRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.materialize.v0.WatchPermissionSetsResponse
 */
export class WatchPermissionSetsResponse extends Message<WatchPermissionSetsResponse> {
  /**
   * @generated from oneof authzed.api.materialize.v0.WatchPermissionSetsResponse.response
   */
  response: {
    /**
     * change is the permission set delta that has occurred as result of a mutation in origin SpiceDB.
     * The consumer should apply this change to the current state of the permission sets in their target system.
     * Once an event arrives with completed_revision instead, the consumer shall consider the set of
     * changes originating from that revision completed.
     *
     * The consumer should keep track of the revision in order to resume streaming in the event of consumer restarts.
     *
     * @generated from field: authzed.api.materialize.v0.PermissionSetChange change = 1;
     */
    value: PermissionSetChange;
    case: "change";
  } | {
    /**
     * completed_revision is the revision token that indicates the completion of a set of changes. It may also be
     * received without accompanying set of changes, indicating that a mutation in the origin SpiceDB cluster did
     * not yield any effective changes in the permission sets
     *
     * @generated from field: authzed.api.v1.ZedToken completed_revision = 2;
     */
    value: ZedToken;
    case: "completedRevision";
  } | {
    /**
     * lookup_permission_sets_required is a signal that the consumer should perform a LookupPermissionSets call because
     * the permission set snapshot needs to be rebuilt from scratch. This typically happens when the origin SpiceDB
     * cluster has seen its schema changed.
     *
     * @generated from field: authzed.api.materialize.v0.LookupPermissionSetsRequired lookup_permission_sets_required = 3;
     */
    value: LookupPermissionSetsRequired;
    case: "lookupPermissionSetsRequired";
  } | {
    /**
     * breaking_schema_change is a signal that a breaking schema change has been written to the origin SpiceDB cluster,
     * and that the consumer should expect delays in the ingestion of new changes,
     * because the permission set snapshot needs to be rebuilt from scratch. Once the snapshot is ready, the consumer
     * will receive a LookupPermissionSetsRequired event.
     *
     * @generated from field: authzed.api.materialize.v0.BreakingSchemaChange breaking_schema_change = 4;
     */
    value: BreakingSchemaChange;
    case: "breakingSchemaChange";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<WatchPermissionSetsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.WatchPermissionSetsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "change", kind: "message", T: PermissionSetChange, oneof: "response" },
    { no: 2, name: "completed_revision", kind: "message", T: ZedToken, oneof: "response" },
    { no: 3, name: "lookup_permission_sets_required", kind: "message", T: LookupPermissionSetsRequired, oneof: "response" },
    { no: 4, name: "breaking_schema_change", kind: "message", T: BreakingSchemaChange, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WatchPermissionSetsResponse {
    return new WatchPermissionSetsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WatchPermissionSetsResponse {
    return new WatchPermissionSetsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WatchPermissionSetsResponse {
    return new WatchPermissionSetsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WatchPermissionSetsResponse | PlainMessage<WatchPermissionSetsResponse> | undefined, b: WatchPermissionSetsResponse | PlainMessage<WatchPermissionSetsResponse> | undefined): boolean {
    return proto3.util.equals(WatchPermissionSetsResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.materialize.v0.Cursor
 */
export class Cursor extends Message<Cursor> {
  /**
   * limit is the number of permission sets to stream over a single LookupPermissionSets call that was requested.
   *
   * @generated from field: uint32 limit = 1;
   */
  limit = 0;

  /**
   * token is the snapshot revision at which the cursor was computed.
   *
   * @generated from field: authzed.api.v1.ZedToken token = 4;
   */
  token?: ZedToken;

  /**
   * starting_index is an offset of the permission set represented by this cursor
   *
   * @generated from field: uint32 starting_index = 5;
   */
  startingIndex = 0;

  /**
   * completed_members is a boolean flag that indicates that the cursor has reached the end of the permission sets
   *
   * @generated from field: bool completed_members = 6;
   */
  completedMembers = false;

  /**
   * starting_key is a string cursor used by some backends to resume the stream from a specific point.
   *
   * @generated from field: string starting_key = 7;
   */
  startingKey = "";

  constructor(data?: PartialMessage<Cursor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.Cursor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "token", kind: "message", T: ZedToken },
    { no: 5, name: "starting_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "completed_members", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "starting_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cursor {
    return new Cursor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJsonString(jsonString, options);
  }

  static equals(a: Cursor | PlainMessage<Cursor> | undefined, b: Cursor | PlainMessage<Cursor> | undefined): boolean {
    return proto3.util.equals(Cursor, a, b);
  }
}

/**
 * @generated from message authzed.api.materialize.v0.LookupPermissionSetsRequest
 */
export class LookupPermissionSetsRequest extends Message<LookupPermissionSetsRequest> {
  /**
   * limit is the number of permission sets to stream over a single LookupPermissionSets. Once the limit is reached,
   * the server will close the stream. If more permission sets are available, the consume should open a new stream
   * providing optional_starting_after_cursor, using the cursor from the last response.
   *
   * @generated from field: uint32 limit = 1;
   */
  limit = 0;

  /**
   * optional_at_revision specifies the client is requesting to lookup PermissionSets at a specific revision. It's
   * optional, and if not provided, PermissionSets will be looked up at the current revision. The cursor always
   * takes precedence in defining the revision when present.
   *
   * @generated from field: authzed.api.v1.ZedToken optional_at_revision = 2;
   */
  optionalAtRevision?: ZedToken;

  /**
   * optional_starting_after_cursor is used to specify the offset to start streaming permission sets from.
   *
   * @generated from field: authzed.api.materialize.v0.Cursor optional_starting_after_cursor = 4;
   */
  optionalStartingAfterCursor?: Cursor;

  constructor(data?: PartialMessage<LookupPermissionSetsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.LookupPermissionSetsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "optional_at_revision", kind: "message", T: ZedToken },
    { no: 4, name: "optional_starting_after_cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupPermissionSetsRequest {
    return new LookupPermissionSetsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupPermissionSetsRequest {
    return new LookupPermissionSetsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupPermissionSetsRequest {
    return new LookupPermissionSetsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LookupPermissionSetsRequest | PlainMessage<LookupPermissionSetsRequest> | undefined, b: LookupPermissionSetsRequest | PlainMessage<LookupPermissionSetsRequest> | undefined): boolean {
    return proto3.util.equals(LookupPermissionSetsRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.materialize.v0.LookupPermissionSetsResponse
 */
export class LookupPermissionSetsResponse extends Message<LookupPermissionSetsResponse> {
  /**
   * change represents the permission set delta necessary to transition an uninitialized target system to
   * a specific snapshot revision. In practice it's not different from the WatchPermissionSetsResponse.change, except
   * all changes will be of time SET_OPERATION_ADDED because it's assumed there is no known previous state.
   *
   * Applying the deltas to a previously initialized target system would yield incorrect results.
   *
   * @generated from field: authzed.api.materialize.v0.PermissionSetChange change = 1;
   */
  change?: PermissionSetChange;

  /**
   * cursor points to a specific permission set in a revision.
   * The consumer should keep track of the cursor in order to resume streaming in the event of consumer restarts. This
   * is particularly important in backfill scenarios that may take hours or event days to complete.
   *
   * @generated from field: authzed.api.materialize.v0.Cursor cursor = 2;
   */
  cursor?: Cursor;

  constructor(data?: PartialMessage<LookupPermissionSetsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.LookupPermissionSetsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "change", kind: "message", T: PermissionSetChange },
    { no: 2, name: "cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupPermissionSetsResponse {
    return new LookupPermissionSetsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupPermissionSetsResponse {
    return new LookupPermissionSetsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupPermissionSetsResponse {
    return new LookupPermissionSetsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LookupPermissionSetsResponse | PlainMessage<LookupPermissionSetsResponse> | undefined, b: LookupPermissionSetsResponse | PlainMessage<LookupPermissionSetsResponse> | undefined): boolean {
    return proto3.util.equals(LookupPermissionSetsResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.materialize.v0.PermissionSetChange
 */
export class PermissionSetChange extends Message<PermissionSetChange> {
  /**
   * revision represents the revision at which the permission set change occurred.
   *
   * @generated from field: authzed.api.v1.ZedToken at_revision = 1;
   */
  atRevision?: ZedToken;

  /**
   * operation represents the type of set operation that took place as part of the change
   *
   * @generated from field: authzed.api.materialize.v0.PermissionSetChange.SetOperation operation = 2;
   */
  operation = PermissionSetChange_SetOperation.UNSPECIFIED;

  /**
   * parent_set represents the permission set parent of either another set or a member
   *
   * @generated from field: authzed.api.materialize.v0.SetReference parent_set = 3;
   */
  parentSet?: SetReference;

  /**
   * @generated from oneof authzed.api.materialize.v0.PermissionSetChange.child
   */
  child: {
    /**
     * child_set represents the scenario where another set is considered member of the parent set
     *
     * @generated from field: authzed.api.materialize.v0.SetReference child_set = 4;
     */
    value: SetReference;
    case: "childSet";
  } | {
    /**
     * child_member represents the scenario where an specific object is considered member of the parent set
     *
     * @generated from field: authzed.api.materialize.v0.MemberReference child_member = 5;
     */
    value: MemberReference;
    case: "childMember";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PermissionSetChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.PermissionSetChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "at_revision", kind: "message", T: ZedToken },
    { no: 2, name: "operation", kind: "enum", T: proto3.getEnumType(PermissionSetChange_SetOperation) },
    { no: 3, name: "parent_set", kind: "message", T: SetReference },
    { no: 4, name: "child_set", kind: "message", T: SetReference, oneof: "child" },
    { no: 5, name: "child_member", kind: "message", T: MemberReference, oneof: "child" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PermissionSetChange {
    return new PermissionSetChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PermissionSetChange {
    return new PermissionSetChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PermissionSetChange {
    return new PermissionSetChange().fromJsonString(jsonString, options);
  }

  static equals(a: PermissionSetChange | PlainMessage<PermissionSetChange> | undefined, b: PermissionSetChange | PlainMessage<PermissionSetChange> | undefined): boolean {
    return proto3.util.equals(PermissionSetChange, a, b);
  }
}

/**
 * @generated from enum authzed.api.materialize.v0.PermissionSetChange.SetOperation
 */
export enum PermissionSetChange_SetOperation {
  /**
   * @generated from enum value: SET_OPERATION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SET_OPERATION_ADDED = 1;
   */
  ADDED = 1,

  /**
   * @generated from enum value: SET_OPERATION_REMOVED = 2;
   */
  REMOVED = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(PermissionSetChange_SetOperation)
proto3.util.setEnumType(PermissionSetChange_SetOperation, "authzed.api.materialize.v0.PermissionSetChange.SetOperation", [
  { no: 0, name: "SET_OPERATION_UNSPECIFIED" },
  { no: 1, name: "SET_OPERATION_ADDED" },
  { no: 2, name: "SET_OPERATION_REMOVED" },
]);

/**
 * @generated from message authzed.api.materialize.v0.SetReference
 */
export class SetReference extends Message<SetReference> {
  /**
   * object_type is the type of object in a permission set
   *
   * @generated from field: string object_type = 1;
   */
  objectType = "";

  /**
   * object_id is the ID of a permission set
   *
   * @generated from field: string object_id = 2;
   */
  objectId = "";

  /**
   * permission_or_relation is the permission or relation referenced by this permission set
   *
   * @generated from field: string permission_or_relation = 3;
   */
  permissionOrRelation = "";

  constructor(data?: PartialMessage<SetReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.SetReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "permission_or_relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetReference {
    return new SetReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetReference {
    return new SetReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetReference {
    return new SetReference().fromJsonString(jsonString, options);
  }

  static equals(a: SetReference | PlainMessage<SetReference> | undefined, b: SetReference | PlainMessage<SetReference> | undefined): boolean {
    return proto3.util.equals(SetReference, a, b);
  }
}

/**
 * @generated from message authzed.api.materialize.v0.MemberReference
 */
export class MemberReference extends Message<MemberReference> {
  /**
   * object_type is the type of object of a permission set member
   *
   * @generated from field: string object_type = 1;
   */
  objectType = "";

  /**
   * object_id is the ID of a permission set member
   *
   * @generated from field: string object_id = 2;
   */
  objectId = "";

  /**
   * optional_permission_or_relation is the permission or relation referenced by this permission set member
   *
   * @generated from field: string optional_permission_or_relation = 3;
   */
  optionalPermissionOrRelation = "";

  constructor(data?: PartialMessage<MemberReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.MemberReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "optional_permission_or_relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemberReference {
    return new MemberReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemberReference {
    return new MemberReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemberReference {
    return new MemberReference().fromJsonString(jsonString, options);
  }

  static equals(a: MemberReference | PlainMessage<MemberReference> | undefined, b: MemberReference | PlainMessage<MemberReference> | undefined): boolean {
    return proto3.util.equals(MemberReference, a, b);
  }
}

/**
 * LookupPermissionSetsRequired is a signal that the consumer should perform a LookupPermissionSets call because
 * the permission set snapshot needs to be rebuilt from scratch. This typically happens when the origin SpiceDB
 * cluster has seen its schema changed, see BreakingSchemaChange event.
 *
 * @generated from message authzed.api.materialize.v0.LookupPermissionSetsRequired
 */
export class LookupPermissionSetsRequired extends Message<LookupPermissionSetsRequired> {
  /**
   * required_lookup_at is the snapshot revision at which the permission set needs to be rebuilt to.
   *
   * @generated from field: authzed.api.v1.ZedToken required_lookup_at = 1;
   */
  requiredLookupAt?: ZedToken;

  constructor(data?: PartialMessage<LookupPermissionSetsRequired>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.LookupPermissionSetsRequired";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "required_lookup_at", kind: "message", T: ZedToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupPermissionSetsRequired {
    return new LookupPermissionSetsRequired().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupPermissionSetsRequired {
    return new LookupPermissionSetsRequired().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupPermissionSetsRequired {
    return new LookupPermissionSetsRequired().fromJsonString(jsonString, options);
  }

  static equals(a: LookupPermissionSetsRequired | PlainMessage<LookupPermissionSetsRequired> | undefined, b: LookupPermissionSetsRequired | PlainMessage<LookupPermissionSetsRequired> | undefined): boolean {
    return proto3.util.equals(LookupPermissionSetsRequired, a, b);
  }
}

/**
 * BreakingSchemaChange is used to signal a breaking schema change has happened, and that the consumer should
 * expect delays in the ingestion of new changes, because the permission set snapshot needs to be rebuilt from scratch.
 * Once the snapshot is ready, the consumer will receive a LookupPermissionSetsRequired event.
 *
 * @generated from message authzed.api.materialize.v0.BreakingSchemaChange
 */
export class BreakingSchemaChange extends Message<BreakingSchemaChange> {
  /**
   * change_at is the revision at which a breaking schema event has happened.
   *
   * @generated from field: authzed.api.v1.ZedToken change_at = 1;
   */
  changeAt?: ZedToken;

  constructor(data?: PartialMessage<BreakingSchemaChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.materialize.v0.BreakingSchemaChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "change_at", kind: "message", T: ZedToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BreakingSchemaChange {
    return new BreakingSchemaChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BreakingSchemaChange {
    return new BreakingSchemaChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BreakingSchemaChange {
    return new BreakingSchemaChange().fromJsonString(jsonString, options);
  }

  static equals(a: BreakingSchemaChange | PlainMessage<BreakingSchemaChange> | undefined, b: BreakingSchemaChange | PlainMessage<BreakingSchemaChange> | undefined): boolean {
    return proto3.util.equals(BreakingSchemaChange, a, b);
  }
}

