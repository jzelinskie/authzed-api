// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file authzed/api/v1/experimental_service.proto (package authzed.api.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct } from "@bufbuild/protobuf";
import { CheckPermissionResponse_Permissionship, Consistency, RelationshipFilter } from "./permission_service_pb.js";
import { Cursor, ObjectReference, PartialCaveatInfo, Relationship, SubjectReference, ZedToken } from "./core_pb.js";
import { Status } from "../../../google/rpc/status_pb.js";

/**
 * @generated from message authzed.api.v1.ExperimentalRegisterRelationshipCounterRequest
 */
export class ExperimentalRegisterRelationshipCounterRequest extends Message<ExperimentalRegisterRelationshipCounterRequest> {
  /**
   * name is the name of the counter being registered.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * relationship_filter defines the filter to be applied to the relationships
   * to be counted.
   *
   * @generated from field: authzed.api.v1.RelationshipFilter relationship_filter = 2;
   */
  relationshipFilter?: RelationshipFilter;

  constructor(data?: PartialMessage<ExperimentalRegisterRelationshipCounterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalRegisterRelationshipCounterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "relationship_filter", kind: "message", T: RelationshipFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalRegisterRelationshipCounterRequest {
    return new ExperimentalRegisterRelationshipCounterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalRegisterRelationshipCounterRequest {
    return new ExperimentalRegisterRelationshipCounterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalRegisterRelationshipCounterRequest {
    return new ExperimentalRegisterRelationshipCounterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalRegisterRelationshipCounterRequest | PlainMessage<ExperimentalRegisterRelationshipCounterRequest> | undefined, b: ExperimentalRegisterRelationshipCounterRequest | PlainMessage<ExperimentalRegisterRelationshipCounterRequest> | undefined): boolean {
    return proto3.util.equals(ExperimentalRegisterRelationshipCounterRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalRegisterRelationshipCounterResponse
 */
export class ExperimentalRegisterRelationshipCounterResponse extends Message<ExperimentalRegisterRelationshipCounterResponse> {
  constructor(data?: PartialMessage<ExperimentalRegisterRelationshipCounterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalRegisterRelationshipCounterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalRegisterRelationshipCounterResponse {
    return new ExperimentalRegisterRelationshipCounterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalRegisterRelationshipCounterResponse {
    return new ExperimentalRegisterRelationshipCounterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalRegisterRelationshipCounterResponse {
    return new ExperimentalRegisterRelationshipCounterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalRegisterRelationshipCounterResponse | PlainMessage<ExperimentalRegisterRelationshipCounterResponse> | undefined, b: ExperimentalRegisterRelationshipCounterResponse | PlainMessage<ExperimentalRegisterRelationshipCounterResponse> | undefined): boolean {
    return proto3.util.equals(ExperimentalRegisterRelationshipCounterResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalCountRelationshipsRequest
 */
export class ExperimentalCountRelationshipsRequest extends Message<ExperimentalCountRelationshipsRequest> {
  /**
   * name is the name of the counter whose count is being requested.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<ExperimentalCountRelationshipsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalCountRelationshipsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalCountRelationshipsRequest {
    return new ExperimentalCountRelationshipsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalCountRelationshipsRequest {
    return new ExperimentalCountRelationshipsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalCountRelationshipsRequest {
    return new ExperimentalCountRelationshipsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalCountRelationshipsRequest | PlainMessage<ExperimentalCountRelationshipsRequest> | undefined, b: ExperimentalCountRelationshipsRequest | PlainMessage<ExperimentalCountRelationshipsRequest> | undefined): boolean {
    return proto3.util.equals(ExperimentalCountRelationshipsRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalCountRelationshipsResponse
 */
export class ExperimentalCountRelationshipsResponse extends Message<ExperimentalCountRelationshipsResponse> {
  /**
   * @generated from oneof authzed.api.v1.ExperimentalCountRelationshipsResponse.counter_result
   */
  counterResult: {
    /**
     * counter_still_calculating is true if the counter is still calculating the count.
     *
     * @generated from field: bool counter_still_calculating = 1;
     */
    value: boolean;
    case: "counterStillCalculating";
  } | {
    /**
     * read_counter_value is the value of the counter at the time of the read.
     *
     * @generated from field: authzed.api.v1.ReadCounterValue read_counter_value = 2;
     */
    value: ReadCounterValue;
    case: "readCounterValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExperimentalCountRelationshipsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalCountRelationshipsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "counter_still_calculating", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "counter_result" },
    { no: 2, name: "read_counter_value", kind: "message", T: ReadCounterValue, oneof: "counter_result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalCountRelationshipsResponse {
    return new ExperimentalCountRelationshipsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalCountRelationshipsResponse {
    return new ExperimentalCountRelationshipsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalCountRelationshipsResponse {
    return new ExperimentalCountRelationshipsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalCountRelationshipsResponse | PlainMessage<ExperimentalCountRelationshipsResponse> | undefined, b: ExperimentalCountRelationshipsResponse | PlainMessage<ExperimentalCountRelationshipsResponse> | undefined): boolean {
    return proto3.util.equals(ExperimentalCountRelationshipsResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ReadCounterValue
 */
export class ReadCounterValue extends Message<ReadCounterValue> {
  /**
   * relationship_count is the count of relationships that match the filter.
   *
   * @generated from field: uint64 relationship_count = 1;
   */
  relationshipCount = protoInt64.zero;

  /**
   * read_at is the ZedToken at which the relationship count applies.
   *
   * @generated from field: authzed.api.v1.ZedToken read_at = 2;
   */
  readAt?: ZedToken;

  constructor(data?: PartialMessage<ReadCounterValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ReadCounterValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relationship_count", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "read_at", kind: "message", T: ZedToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadCounterValue {
    return new ReadCounterValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadCounterValue {
    return new ReadCounterValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadCounterValue {
    return new ReadCounterValue().fromJsonString(jsonString, options);
  }

  static equals(a: ReadCounterValue | PlainMessage<ReadCounterValue> | undefined, b: ReadCounterValue | PlainMessage<ReadCounterValue> | undefined): boolean {
    return proto3.util.equals(ReadCounterValue, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalUnregisterRelationshipCounterRequest
 */
export class ExperimentalUnregisterRelationshipCounterRequest extends Message<ExperimentalUnregisterRelationshipCounterRequest> {
  /**
   * name is the name of the counter being unregistered.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<ExperimentalUnregisterRelationshipCounterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalUnregisterRelationshipCounterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalUnregisterRelationshipCounterRequest {
    return new ExperimentalUnregisterRelationshipCounterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalUnregisterRelationshipCounterRequest {
    return new ExperimentalUnregisterRelationshipCounterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalUnregisterRelationshipCounterRequest {
    return new ExperimentalUnregisterRelationshipCounterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalUnregisterRelationshipCounterRequest | PlainMessage<ExperimentalUnregisterRelationshipCounterRequest> | undefined, b: ExperimentalUnregisterRelationshipCounterRequest | PlainMessage<ExperimentalUnregisterRelationshipCounterRequest> | undefined): boolean {
    return proto3.util.equals(ExperimentalUnregisterRelationshipCounterRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalUnregisterRelationshipCounterResponse
 */
export class ExperimentalUnregisterRelationshipCounterResponse extends Message<ExperimentalUnregisterRelationshipCounterResponse> {
  constructor(data?: PartialMessage<ExperimentalUnregisterRelationshipCounterResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalUnregisterRelationshipCounterResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalUnregisterRelationshipCounterResponse {
    return new ExperimentalUnregisterRelationshipCounterResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalUnregisterRelationshipCounterResponse {
    return new ExperimentalUnregisterRelationshipCounterResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalUnregisterRelationshipCounterResponse {
    return new ExperimentalUnregisterRelationshipCounterResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalUnregisterRelationshipCounterResponse | PlainMessage<ExperimentalUnregisterRelationshipCounterResponse> | undefined, b: ExperimentalUnregisterRelationshipCounterResponse | PlainMessage<ExperimentalUnregisterRelationshipCounterResponse> | undefined): boolean {
    return proto3.util.equals(ExperimentalUnregisterRelationshipCounterResponse, a, b);
  }
}

/**
 * NOTE: Deprecated now that BulkCheckPermission has been promoted to the stable API as "CheckBulkPermission".
 *
 * @generated from message authzed.api.v1.BulkCheckPermissionRequest
 */
export class BulkCheckPermissionRequest extends Message<BulkCheckPermissionRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * @generated from field: repeated authzed.api.v1.BulkCheckPermissionRequestItem items = 2 [deprecated = true];
   * @deprecated
   */
  items: BulkCheckPermissionRequestItem[] = [];

  constructor(data?: PartialMessage<BulkCheckPermissionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.BulkCheckPermissionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "items", kind: "message", T: BulkCheckPermissionRequestItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkCheckPermissionRequest {
    return new BulkCheckPermissionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkCheckPermissionRequest {
    return new BulkCheckPermissionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkCheckPermissionRequest {
    return new BulkCheckPermissionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BulkCheckPermissionRequest | PlainMessage<BulkCheckPermissionRequest> | undefined, b: BulkCheckPermissionRequest | PlainMessage<BulkCheckPermissionRequest> | undefined): boolean {
    return proto3.util.equals(BulkCheckPermissionRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.BulkCheckPermissionRequestItem
 */
export class BulkCheckPermissionRequestItem extends Message<BulkCheckPermissionRequestItem> {
  /**
   * @generated from field: authzed.api.v1.ObjectReference resource = 1;
   */
  resource?: ObjectReference;

  /**
   * @generated from field: string permission = 2;
   */
  permission = "";

  /**
   * @generated from field: authzed.api.v1.SubjectReference subject = 3;
   */
  subject?: SubjectReference;

  /**
   * @generated from field: google.protobuf.Struct context = 4;
   */
  context?: Struct;

  constructor(data?: PartialMessage<BulkCheckPermissionRequestItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.BulkCheckPermissionRequestItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: ObjectReference },
    { no: 2, name: "permission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subject", kind: "message", T: SubjectReference },
    { no: 4, name: "context", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkCheckPermissionRequestItem {
    return new BulkCheckPermissionRequestItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkCheckPermissionRequestItem {
    return new BulkCheckPermissionRequestItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkCheckPermissionRequestItem {
    return new BulkCheckPermissionRequestItem().fromJsonString(jsonString, options);
  }

  static equals(a: BulkCheckPermissionRequestItem | PlainMessage<BulkCheckPermissionRequestItem> | undefined, b: BulkCheckPermissionRequestItem | PlainMessage<BulkCheckPermissionRequestItem> | undefined): boolean {
    return proto3.util.equals(BulkCheckPermissionRequestItem, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.BulkCheckPermissionResponse
 */
export class BulkCheckPermissionResponse extends Message<BulkCheckPermissionResponse> {
  /**
   * @generated from field: authzed.api.v1.ZedToken checked_at = 1;
   */
  checkedAt?: ZedToken;

  /**
   * @generated from field: repeated authzed.api.v1.BulkCheckPermissionPair pairs = 2;
   */
  pairs: BulkCheckPermissionPair[] = [];

  constructor(data?: PartialMessage<BulkCheckPermissionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.BulkCheckPermissionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checked_at", kind: "message", T: ZedToken },
    { no: 2, name: "pairs", kind: "message", T: BulkCheckPermissionPair, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkCheckPermissionResponse {
    return new BulkCheckPermissionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkCheckPermissionResponse {
    return new BulkCheckPermissionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkCheckPermissionResponse {
    return new BulkCheckPermissionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BulkCheckPermissionResponse | PlainMessage<BulkCheckPermissionResponse> | undefined, b: BulkCheckPermissionResponse | PlainMessage<BulkCheckPermissionResponse> | undefined): boolean {
    return proto3.util.equals(BulkCheckPermissionResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.BulkCheckPermissionPair
 */
export class BulkCheckPermissionPair extends Message<BulkCheckPermissionPair> {
  /**
   * @generated from field: authzed.api.v1.BulkCheckPermissionRequestItem request = 1;
   */
  request?: BulkCheckPermissionRequestItem;

  /**
   * @generated from oneof authzed.api.v1.BulkCheckPermissionPair.response
   */
  response: {
    /**
     * @generated from field: authzed.api.v1.BulkCheckPermissionResponseItem item = 2;
     */
    value: BulkCheckPermissionResponseItem;
    case: "item";
  } | {
    /**
     * @generated from field: google.rpc.Status error = 3;
     */
    value: Status;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BulkCheckPermissionPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.BulkCheckPermissionPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: BulkCheckPermissionRequestItem },
    { no: 2, name: "item", kind: "message", T: BulkCheckPermissionResponseItem, oneof: "response" },
    { no: 3, name: "error", kind: "message", T: Status, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkCheckPermissionPair {
    return new BulkCheckPermissionPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkCheckPermissionPair {
    return new BulkCheckPermissionPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkCheckPermissionPair {
    return new BulkCheckPermissionPair().fromJsonString(jsonString, options);
  }

  static equals(a: BulkCheckPermissionPair | PlainMessage<BulkCheckPermissionPair> | undefined, b: BulkCheckPermissionPair | PlainMessage<BulkCheckPermissionPair> | undefined): boolean {
    return proto3.util.equals(BulkCheckPermissionPair, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.BulkCheckPermissionResponseItem
 */
export class BulkCheckPermissionResponseItem extends Message<BulkCheckPermissionResponseItem> {
  /**
   * @generated from field: authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 1;
   */
  permissionship = CheckPermissionResponse_Permissionship.UNSPECIFIED;

  /**
   * @generated from field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 2;
   */
  partialCaveatInfo?: PartialCaveatInfo;

  constructor(data?: PartialMessage<BulkCheckPermissionResponseItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.BulkCheckPermissionResponseItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "permissionship", kind: "enum", T: proto3.getEnumType(CheckPermissionResponse_Permissionship) },
    { no: 2, name: "partial_caveat_info", kind: "message", T: PartialCaveatInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkCheckPermissionResponseItem {
    return new BulkCheckPermissionResponseItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkCheckPermissionResponseItem {
    return new BulkCheckPermissionResponseItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkCheckPermissionResponseItem {
    return new BulkCheckPermissionResponseItem().fromJsonString(jsonString, options);
  }

  static equals(a: BulkCheckPermissionResponseItem | PlainMessage<BulkCheckPermissionResponseItem> | undefined, b: BulkCheckPermissionResponseItem | PlainMessage<BulkCheckPermissionResponseItem> | undefined): boolean {
    return proto3.util.equals(BulkCheckPermissionResponseItem, a, b);
  }
}

/**
 * BulkImportRelationshipsRequest represents one batch of the streaming
 * BulkImportRelationships API. The maximum size is only limited by the backing
 * datastore, and optimal size should be determined by the calling client
 * experimentally. When BulkImport is invoked and receives its first request message,
 * a transaction is opened to import the relationships. All requests sent to the same
 * invocation are executed under this single transaction. If a relationship already
 * exists within the datastore, the entire transaction will fail with an error.
 *
 * @generated from message authzed.api.v1.BulkImportRelationshipsRequest
 */
export class BulkImportRelationshipsRequest extends Message<BulkImportRelationshipsRequest> {
  /**
   * @generated from field: repeated authzed.api.v1.Relationship relationships = 1;
   */
  relationships: Relationship[] = [];

  constructor(data?: PartialMessage<BulkImportRelationshipsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.BulkImportRelationshipsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relationships", kind: "message", T: Relationship, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkImportRelationshipsRequest {
    return new BulkImportRelationshipsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkImportRelationshipsRequest {
    return new BulkImportRelationshipsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkImportRelationshipsRequest {
    return new BulkImportRelationshipsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BulkImportRelationshipsRequest | PlainMessage<BulkImportRelationshipsRequest> | undefined, b: BulkImportRelationshipsRequest | PlainMessage<BulkImportRelationshipsRequest> | undefined): boolean {
    return proto3.util.equals(BulkImportRelationshipsRequest, a, b);
  }
}

/**
 * BulkImportRelationshipsResponse is returned on successful completion of the
 * bulk load stream, and contains the total number of relationships loaded.
 *
 * @generated from message authzed.api.v1.BulkImportRelationshipsResponse
 */
export class BulkImportRelationshipsResponse extends Message<BulkImportRelationshipsResponse> {
  /**
   * @generated from field: uint64 num_loaded = 1;
   */
  numLoaded = protoInt64.zero;

  constructor(data?: PartialMessage<BulkImportRelationshipsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.BulkImportRelationshipsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_loaded", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkImportRelationshipsResponse {
    return new BulkImportRelationshipsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkImportRelationshipsResponse {
    return new BulkImportRelationshipsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkImportRelationshipsResponse {
    return new BulkImportRelationshipsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BulkImportRelationshipsResponse | PlainMessage<BulkImportRelationshipsResponse> | undefined, b: BulkImportRelationshipsResponse | PlainMessage<BulkImportRelationshipsResponse> | undefined): boolean {
    return proto3.util.equals(BulkImportRelationshipsResponse, a, b);
  }
}

/**
 * BulkExportRelationshipsRequest represents a resumable request for
 * all relationships from the server.
 *
 * @generated from message authzed.api.v1.BulkExportRelationshipsRequest
 */
export class BulkExportRelationshipsRequest extends Message<BulkExportRelationshipsRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * optional_limit, if non-zero, specifies the limit on the number of
   * relationships the server can return in one page. By default, the server
   * will pick a page size, and the server is free to choose a smaller size
   * at will.
   *
   * @generated from field: uint32 optional_limit = 2;
   */
  optionalLimit = 0;

  /**
   * optional_cursor, if specified, indicates the cursor after which results
   * should resume being returned. The cursor can be found on the
   * BulkExportRelationshipsResponse object.
   *
   * @generated from field: authzed.api.v1.Cursor optional_cursor = 3;
   */
  optionalCursor?: Cursor;

  /**
   * optional_relationship_filter, if specified, indicates the
   * filter to apply to each relationship to be exported.
   *
   * @generated from field: authzed.api.v1.RelationshipFilter optional_relationship_filter = 4;
   */
  optionalRelationshipFilter?: RelationshipFilter;

  constructor(data?: PartialMessage<BulkExportRelationshipsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.BulkExportRelationshipsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "optional_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "optional_cursor", kind: "message", T: Cursor },
    { no: 4, name: "optional_relationship_filter", kind: "message", T: RelationshipFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkExportRelationshipsRequest {
    return new BulkExportRelationshipsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkExportRelationshipsRequest {
    return new BulkExportRelationshipsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkExportRelationshipsRequest {
    return new BulkExportRelationshipsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BulkExportRelationshipsRequest | PlainMessage<BulkExportRelationshipsRequest> | undefined, b: BulkExportRelationshipsRequest | PlainMessage<BulkExportRelationshipsRequest> | undefined): boolean {
    return proto3.util.equals(BulkExportRelationshipsRequest, a, b);
  }
}

/**
 * BulkExportRelationshipsResponse is one page in a stream of relationship
 * groups that meet the criteria specified by the originating request. The
 * server will continue to stream back relationship groups as quickly as it can
 * until all relationships have been transmitted back.
 *
 * @generated from message authzed.api.v1.BulkExportRelationshipsResponse
 */
export class BulkExportRelationshipsResponse extends Message<BulkExportRelationshipsResponse> {
  /**
   * @generated from field: authzed.api.v1.Cursor after_result_cursor = 1;
   */
  afterResultCursor?: Cursor;

  /**
   * @generated from field: repeated authzed.api.v1.Relationship relationships = 2;
   */
  relationships: Relationship[] = [];

  constructor(data?: PartialMessage<BulkExportRelationshipsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.BulkExportRelationshipsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "after_result_cursor", kind: "message", T: Cursor },
    { no: 2, name: "relationships", kind: "message", T: Relationship, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BulkExportRelationshipsResponse {
    return new BulkExportRelationshipsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BulkExportRelationshipsResponse {
    return new BulkExportRelationshipsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BulkExportRelationshipsResponse {
    return new BulkExportRelationshipsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BulkExportRelationshipsResponse | PlainMessage<BulkExportRelationshipsResponse> | undefined, b: BulkExportRelationshipsResponse | PlainMessage<BulkExportRelationshipsResponse> | undefined): boolean {
    return proto3.util.equals(BulkExportRelationshipsResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalReflectSchemaRequest
 */
export class ExperimentalReflectSchemaRequest extends Message<ExperimentalReflectSchemaRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * optional_filters defines optional filters that are applied in
   * an OR fashion to the schema, before being returned
   *
   * @generated from field: repeated authzed.api.v1.ExpSchemaFilter optional_filters = 2;
   */
  optionalFilters: ExpSchemaFilter[] = [];

  constructor(data?: PartialMessage<ExperimentalReflectSchemaRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalReflectSchemaRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "optional_filters", kind: "message", T: ExpSchemaFilter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalReflectSchemaRequest {
    return new ExperimentalReflectSchemaRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalReflectSchemaRequest {
    return new ExperimentalReflectSchemaRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalReflectSchemaRequest {
    return new ExperimentalReflectSchemaRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalReflectSchemaRequest | PlainMessage<ExperimentalReflectSchemaRequest> | undefined, b: ExperimentalReflectSchemaRequest | PlainMessage<ExperimentalReflectSchemaRequest> | undefined): boolean {
    return proto3.util.equals(ExperimentalReflectSchemaRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalReflectSchemaResponse
 */
export class ExperimentalReflectSchemaResponse extends Message<ExperimentalReflectSchemaResponse> {
  /**
   * definitions are the definitions defined in the schema.
   *
   * @generated from field: repeated authzed.api.v1.ExpDefinition definitions = 1;
   */
  definitions: ExpDefinition[] = [];

  /**
   * caveats are the caveats defined in the schema.
   *
   * @generated from field: repeated authzed.api.v1.ExpCaveat caveats = 2;
   */
  caveats: ExpCaveat[] = [];

  /**
   * read_at is the ZedToken at which the schema was read.
   *
   * @generated from field: authzed.api.v1.ZedToken read_at = 3;
   */
  readAt?: ZedToken;

  constructor(data?: PartialMessage<ExperimentalReflectSchemaResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalReflectSchemaResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "definitions", kind: "message", T: ExpDefinition, repeated: true },
    { no: 2, name: "caveats", kind: "message", T: ExpCaveat, repeated: true },
    { no: 3, name: "read_at", kind: "message", T: ZedToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalReflectSchemaResponse {
    return new ExperimentalReflectSchemaResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalReflectSchemaResponse {
    return new ExperimentalReflectSchemaResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalReflectSchemaResponse {
    return new ExperimentalReflectSchemaResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalReflectSchemaResponse | PlainMessage<ExperimentalReflectSchemaResponse> | undefined, b: ExperimentalReflectSchemaResponse | PlainMessage<ExperimentalReflectSchemaResponse> | undefined): boolean {
    return proto3.util.equals(ExperimentalReflectSchemaResponse, a, b);
  }
}

/**
 * ExpSchemaFilter is a filter that can be applied to the schema on reflection.
 *
 * @generated from message authzed.api.v1.ExpSchemaFilter
 */
export class ExpSchemaFilter extends Message<ExpSchemaFilter> {
  /**
   * optional_definition_name_filter is a prefix that is matched against the definition name.
   *
   * @generated from field: string optional_definition_name_filter = 1;
   */
  optionalDefinitionNameFilter = "";

  /**
   * optional_caveat_name_filter is a prefix that is matched against the caveat name.
   *
   * @generated from field: string optional_caveat_name_filter = 2;
   */
  optionalCaveatNameFilter = "";

  /**
   * optional_relation_name_filter is a prefix that is matched against the relation name.
   *
   * @generated from field: string optional_relation_name_filter = 3;
   */
  optionalRelationNameFilter = "";

  /**
   * optional_permission_name_filter is a prefix that is matched against the permission name.
   *
   * @generated from field: string optional_permission_name_filter = 4;
   */
  optionalPermissionNameFilter = "";

  constructor(data?: PartialMessage<ExpSchemaFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpSchemaFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "optional_definition_name_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "optional_caveat_name_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "optional_relation_name_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "optional_permission_name_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpSchemaFilter {
    return new ExpSchemaFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpSchemaFilter {
    return new ExpSchemaFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpSchemaFilter {
    return new ExpSchemaFilter().fromJsonString(jsonString, options);
  }

  static equals(a: ExpSchemaFilter | PlainMessage<ExpSchemaFilter> | undefined, b: ExpSchemaFilter | PlainMessage<ExpSchemaFilter> | undefined): boolean {
    return proto3.util.equals(ExpSchemaFilter, a, b);
  }
}

/**
 * ExpDefinition is the representation of a definition in the schema.
 *
 * @generated from message authzed.api.v1.ExpDefinition
 */
export class ExpDefinition extends Message<ExpDefinition> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * comment is a human-readable comments on the definition. Will include
   * delimiter characters.
   *
   * @generated from field: string comment = 2;
   */
  comment = "";

  /**
   * @generated from field: repeated authzed.api.v1.ExpRelation relations = 3;
   */
  relations: ExpRelation[] = [];

  /**
   * @generated from field: repeated authzed.api.v1.ExpPermission permissions = 4;
   */
  permissions: ExpPermission[] = [];

  constructor(data?: PartialMessage<ExpDefinition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpDefinition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "relations", kind: "message", T: ExpRelation, repeated: true },
    { no: 4, name: "permissions", kind: "message", T: ExpPermission, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpDefinition {
    return new ExpDefinition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpDefinition {
    return new ExpDefinition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpDefinition {
    return new ExpDefinition().fromJsonString(jsonString, options);
  }

  static equals(a: ExpDefinition | PlainMessage<ExpDefinition> | undefined, b: ExpDefinition | PlainMessage<ExpDefinition> | undefined): boolean {
    return proto3.util.equals(ExpDefinition, a, b);
  }
}

/**
 * ExpCaveat is the representation of a caveat in the schema.
 *
 * @generated from message authzed.api.v1.ExpCaveat
 */
export class ExpCaveat extends Message<ExpCaveat> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * comment is a human-readable comments on the caveat. Will include
   * delimiter characters.
   *
   * @generated from field: string comment = 2;
   */
  comment = "";

  /**
   * @generated from field: repeated authzed.api.v1.ExpCaveatParameter parameters = 3;
   */
  parameters: ExpCaveatParameter[] = [];

  /**
   * @generated from field: string expression = 4;
   */
  expression = "";

  constructor(data?: PartialMessage<ExpCaveat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpCaveat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "parameters", kind: "message", T: ExpCaveatParameter, repeated: true },
    { no: 4, name: "expression", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpCaveat {
    return new ExpCaveat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpCaveat {
    return new ExpCaveat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpCaveat {
    return new ExpCaveat().fromJsonString(jsonString, options);
  }

  static equals(a: ExpCaveat | PlainMessage<ExpCaveat> | undefined, b: ExpCaveat | PlainMessage<ExpCaveat> | undefined): boolean {
    return proto3.util.equals(ExpCaveat, a, b);
  }
}

/**
 * ExpCaveatParameter is the representation of a parameter in a caveat.
 *
 * @generated from message authzed.api.v1.ExpCaveatParameter
 */
export class ExpCaveatParameter extends Message<ExpCaveatParameter> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * type is the type of the parameter. Will be a string representing the
   * type, e.g. `int` or `list<string>`
   *
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: string parent_caveat_name = 3;
   */
  parentCaveatName = "";

  constructor(data?: PartialMessage<ExpCaveatParameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpCaveatParameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "parent_caveat_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpCaveatParameter {
    return new ExpCaveatParameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpCaveatParameter {
    return new ExpCaveatParameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpCaveatParameter {
    return new ExpCaveatParameter().fromJsonString(jsonString, options);
  }

  static equals(a: ExpCaveatParameter | PlainMessage<ExpCaveatParameter> | undefined, b: ExpCaveatParameter | PlainMessage<ExpCaveatParameter> | undefined): boolean {
    return proto3.util.equals(ExpCaveatParameter, a, b);
  }
}

/**
 * ExpRelation is the representation of a relation in the schema.
 *
 * @generated from message authzed.api.v1.ExpRelation
 */
export class ExpRelation extends Message<ExpRelation> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string comment = 2;
   */
  comment = "";

  /**
   * @generated from field: string parent_definition_name = 3;
   */
  parentDefinitionName = "";

  /**
   * @generated from field: repeated authzed.api.v1.ExpTypeReference subject_types = 4;
   */
  subjectTypes: ExpTypeReference[] = [];

  constructor(data?: PartialMessage<ExpRelation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpRelation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "parent_definition_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "subject_types", kind: "message", T: ExpTypeReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpRelation {
    return new ExpRelation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpRelation {
    return new ExpRelation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpRelation {
    return new ExpRelation().fromJsonString(jsonString, options);
  }

  static equals(a: ExpRelation | PlainMessage<ExpRelation> | undefined, b: ExpRelation | PlainMessage<ExpRelation> | undefined): boolean {
    return proto3.util.equals(ExpRelation, a, b);
  }
}

/**
 * ExpTypeReference is the representation of a type reference in the schema.
 *
 * @generated from message authzed.api.v1.ExpTypeReference
 */
export class ExpTypeReference extends Message<ExpTypeReference> {
  /**
   * subject_definition_name is the name of the subject's definition.
   *
   * @generated from field: string subject_definition_name = 1;
   */
  subjectDefinitionName = "";

  /**
   * optional_caveat_name is the name of the caveat that is applied to the subject, if any.
   *
   * @generated from field: string optional_caveat_name = 2;
   */
  optionalCaveatName = "";

  /**
   * @generated from oneof authzed.api.v1.ExpTypeReference.typeref
   */
  typeref: {
    /**
     * is_terminal_subject is true if the subject is terminal, meaning it is referenced directly vs a sub-relation.
     *
     * @generated from field: bool is_terminal_subject = 3;
     */
    value: boolean;
    case: "isTerminalSubject";
  } | {
    /**
     * optional_relation_name is the name of the relation that is applied to the subject, if any.
     *
     * @generated from field: string optional_relation_name = 4;
     */
    value: string;
    case: "optionalRelationName";
  } | {
    /**
     * is_public_wildcard is true if the subject is a public wildcard.
     *
     * @generated from field: bool is_public_wildcard = 5;
     */
    value: boolean;
    case: "isPublicWildcard";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExpTypeReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpTypeReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subject_definition_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "optional_caveat_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_terminal_subject", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "typeref" },
    { no: 4, name: "optional_relation_name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "typeref" },
    { no: 5, name: "is_public_wildcard", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "typeref" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpTypeReference {
    return new ExpTypeReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpTypeReference {
    return new ExpTypeReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpTypeReference {
    return new ExpTypeReference().fromJsonString(jsonString, options);
  }

  static equals(a: ExpTypeReference | PlainMessage<ExpTypeReference> | undefined, b: ExpTypeReference | PlainMessage<ExpTypeReference> | undefined): boolean {
    return proto3.util.equals(ExpTypeReference, a, b);
  }
}

/**
 * ExpPermission is the representation of a permission in the schema.
 *
 * @generated from message authzed.api.v1.ExpPermission
 */
export class ExpPermission extends Message<ExpPermission> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * comment is a human-readable comments on the permission. Will include
   * delimiter characters.
   *
   * @generated from field: string comment = 2;
   */
  comment = "";

  /**
   * @generated from field: string parent_definition_name = 3;
   */
  parentDefinitionName = "";

  constructor(data?: PartialMessage<ExpPermission>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpPermission";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "comment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "parent_definition_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpPermission {
    return new ExpPermission().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpPermission {
    return new ExpPermission().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpPermission {
    return new ExpPermission().fromJsonString(jsonString, options);
  }

  static equals(a: ExpPermission | PlainMessage<ExpPermission> | undefined, b: ExpPermission | PlainMessage<ExpPermission> | undefined): boolean {
    return proto3.util.equals(ExpPermission, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalComputablePermissionsRequest
 */
export class ExperimentalComputablePermissionsRequest extends Message<ExperimentalComputablePermissionsRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * @generated from field: string definition_name = 2;
   */
  definitionName = "";

  /**
   * @generated from field: string relation_name = 3;
   */
  relationName = "";

  /**
   * optional_definition_name_match is a prefix that is matched against the definition name(s)
   * for the permissions returned.
   * If not specified, will be ignored.
   *
   * @generated from field: string optional_definition_name_filter = 4;
   */
  optionalDefinitionNameFilter = "";

  constructor(data?: PartialMessage<ExperimentalComputablePermissionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalComputablePermissionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "definition_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "relation_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "optional_definition_name_filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalComputablePermissionsRequest {
    return new ExperimentalComputablePermissionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalComputablePermissionsRequest {
    return new ExperimentalComputablePermissionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalComputablePermissionsRequest {
    return new ExperimentalComputablePermissionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalComputablePermissionsRequest | PlainMessage<ExperimentalComputablePermissionsRequest> | undefined, b: ExperimentalComputablePermissionsRequest | PlainMessage<ExperimentalComputablePermissionsRequest> | undefined): boolean {
    return proto3.util.equals(ExperimentalComputablePermissionsRequest, a, b);
  }
}

/**
 * ExpRelationReference is a reference to a relation or permission in the schema.
 *
 * @generated from message authzed.api.v1.ExpRelationReference
 */
export class ExpRelationReference extends Message<ExpRelationReference> {
  /**
   * @generated from field: string definition_name = 1;
   */
  definitionName = "";

  /**
   * @generated from field: string relation_name = 2;
   */
  relationName = "";

  /**
   * @generated from field: bool is_permission = 3;
   */
  isPermission = false;

  constructor(data?: PartialMessage<ExpRelationReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpRelationReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "definition_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "relation_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "is_permission", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpRelationReference {
    return new ExpRelationReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpRelationReference {
    return new ExpRelationReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpRelationReference {
    return new ExpRelationReference().fromJsonString(jsonString, options);
  }

  static equals(a: ExpRelationReference | PlainMessage<ExpRelationReference> | undefined, b: ExpRelationReference | PlainMessage<ExpRelationReference> | undefined): boolean {
    return proto3.util.equals(ExpRelationReference, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalComputablePermissionsResponse
 */
export class ExperimentalComputablePermissionsResponse extends Message<ExperimentalComputablePermissionsResponse> {
  /**
   * @generated from field: repeated authzed.api.v1.ExpRelationReference permissions = 1;
   */
  permissions: ExpRelationReference[] = [];

  /**
   * read_at is the ZedToken at which the schema was read.
   *
   * @generated from field: authzed.api.v1.ZedToken read_at = 2;
   */
  readAt?: ZedToken;

  constructor(data?: PartialMessage<ExperimentalComputablePermissionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalComputablePermissionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "permissions", kind: "message", T: ExpRelationReference, repeated: true },
    { no: 2, name: "read_at", kind: "message", T: ZedToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalComputablePermissionsResponse {
    return new ExperimentalComputablePermissionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalComputablePermissionsResponse {
    return new ExperimentalComputablePermissionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalComputablePermissionsResponse {
    return new ExperimentalComputablePermissionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalComputablePermissionsResponse | PlainMessage<ExperimentalComputablePermissionsResponse> | undefined, b: ExperimentalComputablePermissionsResponse | PlainMessage<ExperimentalComputablePermissionsResponse> | undefined): boolean {
    return proto3.util.equals(ExperimentalComputablePermissionsResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalDependentRelationsRequest
 */
export class ExperimentalDependentRelationsRequest extends Message<ExperimentalDependentRelationsRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * @generated from field: string definition_name = 2;
   */
  definitionName = "";

  /**
   * @generated from field: string permission_name = 3;
   */
  permissionName = "";

  constructor(data?: PartialMessage<ExperimentalDependentRelationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalDependentRelationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "definition_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "permission_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalDependentRelationsRequest {
    return new ExperimentalDependentRelationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalDependentRelationsRequest {
    return new ExperimentalDependentRelationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalDependentRelationsRequest {
    return new ExperimentalDependentRelationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalDependentRelationsRequest | PlainMessage<ExperimentalDependentRelationsRequest> | undefined, b: ExperimentalDependentRelationsRequest | PlainMessage<ExperimentalDependentRelationsRequest> | undefined): boolean {
    return proto3.util.equals(ExperimentalDependentRelationsRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalDependentRelationsResponse
 */
export class ExperimentalDependentRelationsResponse extends Message<ExperimentalDependentRelationsResponse> {
  /**
   * @generated from field: repeated authzed.api.v1.ExpRelationReference relations = 1;
   */
  relations: ExpRelationReference[] = [];

  /**
   * read_at is the ZedToken at which the schema was read.
   *
   * @generated from field: authzed.api.v1.ZedToken read_at = 2;
   */
  readAt?: ZedToken;

  constructor(data?: PartialMessage<ExperimentalDependentRelationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalDependentRelationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relations", kind: "message", T: ExpRelationReference, repeated: true },
    { no: 2, name: "read_at", kind: "message", T: ZedToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalDependentRelationsResponse {
    return new ExperimentalDependentRelationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalDependentRelationsResponse {
    return new ExperimentalDependentRelationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalDependentRelationsResponse {
    return new ExperimentalDependentRelationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalDependentRelationsResponse | PlainMessage<ExperimentalDependentRelationsResponse> | undefined, b: ExperimentalDependentRelationsResponse | PlainMessage<ExperimentalDependentRelationsResponse> | undefined): boolean {
    return proto3.util.equals(ExperimentalDependentRelationsResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalDiffSchemaRequest
 */
export class ExperimentalDiffSchemaRequest extends Message<ExperimentalDiffSchemaRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * @generated from field: string comparison_schema = 2;
   */
  comparisonSchema = "";

  constructor(data?: PartialMessage<ExperimentalDiffSchemaRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalDiffSchemaRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "comparison_schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalDiffSchemaRequest {
    return new ExperimentalDiffSchemaRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalDiffSchemaRequest {
    return new ExperimentalDiffSchemaRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalDiffSchemaRequest {
    return new ExperimentalDiffSchemaRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalDiffSchemaRequest | PlainMessage<ExperimentalDiffSchemaRequest> | undefined, b: ExperimentalDiffSchemaRequest | PlainMessage<ExperimentalDiffSchemaRequest> | undefined): boolean {
    return proto3.util.equals(ExperimentalDiffSchemaRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExperimentalDiffSchemaResponse
 */
export class ExperimentalDiffSchemaResponse extends Message<ExperimentalDiffSchemaResponse> {
  /**
   * @generated from field: repeated authzed.api.v1.ExpSchemaDiff diffs = 1;
   */
  diffs: ExpSchemaDiff[] = [];

  /**
   * read_at is the ZedToken at which the schema was read.
   *
   * @generated from field: authzed.api.v1.ZedToken read_at = 2;
   */
  readAt?: ZedToken;

  constructor(data?: PartialMessage<ExperimentalDiffSchemaResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExperimentalDiffSchemaResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "diffs", kind: "message", T: ExpSchemaDiff, repeated: true },
    { no: 2, name: "read_at", kind: "message", T: ZedToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExperimentalDiffSchemaResponse {
    return new ExperimentalDiffSchemaResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExperimentalDiffSchemaResponse {
    return new ExperimentalDiffSchemaResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExperimentalDiffSchemaResponse {
    return new ExperimentalDiffSchemaResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExperimentalDiffSchemaResponse | PlainMessage<ExperimentalDiffSchemaResponse> | undefined, b: ExperimentalDiffSchemaResponse | PlainMessage<ExperimentalDiffSchemaResponse> | undefined): boolean {
    return proto3.util.equals(ExperimentalDiffSchemaResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExpRelationSubjectTypeChange
 */
export class ExpRelationSubjectTypeChange extends Message<ExpRelationSubjectTypeChange> {
  /**
   * @generated from field: authzed.api.v1.ExpRelation relation = 1;
   */
  relation?: ExpRelation;

  /**
   * @generated from field: authzed.api.v1.ExpTypeReference changed_subject_type = 2;
   */
  changedSubjectType?: ExpTypeReference;

  constructor(data?: PartialMessage<ExpRelationSubjectTypeChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpRelationSubjectTypeChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relation", kind: "message", T: ExpRelation },
    { no: 2, name: "changed_subject_type", kind: "message", T: ExpTypeReference },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpRelationSubjectTypeChange {
    return new ExpRelationSubjectTypeChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpRelationSubjectTypeChange {
    return new ExpRelationSubjectTypeChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpRelationSubjectTypeChange {
    return new ExpRelationSubjectTypeChange().fromJsonString(jsonString, options);
  }

  static equals(a: ExpRelationSubjectTypeChange | PlainMessage<ExpRelationSubjectTypeChange> | undefined, b: ExpRelationSubjectTypeChange | PlainMessage<ExpRelationSubjectTypeChange> | undefined): boolean {
    return proto3.util.equals(ExpRelationSubjectTypeChange, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExpCaveatParameterTypeChange
 */
export class ExpCaveatParameterTypeChange extends Message<ExpCaveatParameterTypeChange> {
  /**
   * @generated from field: authzed.api.v1.ExpCaveatParameter parameter = 1;
   */
  parameter?: ExpCaveatParameter;

  /**
   * @generated from field: string previous_type = 2;
   */
  previousType = "";

  constructor(data?: PartialMessage<ExpCaveatParameterTypeChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpCaveatParameterTypeChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parameter", kind: "message", T: ExpCaveatParameter },
    { no: 2, name: "previous_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpCaveatParameterTypeChange {
    return new ExpCaveatParameterTypeChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpCaveatParameterTypeChange {
    return new ExpCaveatParameterTypeChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpCaveatParameterTypeChange {
    return new ExpCaveatParameterTypeChange().fromJsonString(jsonString, options);
  }

  static equals(a: ExpCaveatParameterTypeChange | PlainMessage<ExpCaveatParameterTypeChange> | undefined, b: ExpCaveatParameterTypeChange | PlainMessage<ExpCaveatParameterTypeChange> | undefined): boolean {
    return proto3.util.equals(ExpCaveatParameterTypeChange, a, b);
  }
}

/**
 * ExpSchemaDiff is the representation of a diff between two schemas.
 *
 * @generated from message authzed.api.v1.ExpSchemaDiff
 */
export class ExpSchemaDiff extends Message<ExpSchemaDiff> {
  /**
   * @generated from oneof authzed.api.v1.ExpSchemaDiff.diff
   */
  diff: {
    /**
     * @generated from field: authzed.api.v1.ExpDefinition definition_added = 1;
     */
    value: ExpDefinition;
    case: "definitionAdded";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpDefinition definition_removed = 2;
     */
    value: ExpDefinition;
    case: "definitionRemoved";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpDefinition definition_doc_comment_changed = 3;
     */
    value: ExpDefinition;
    case: "definitionDocCommentChanged";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpRelation relation_added = 4;
     */
    value: ExpRelation;
    case: "relationAdded";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpRelation relation_removed = 5;
     */
    value: ExpRelation;
    case: "relationRemoved";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpRelation relation_doc_comment_changed = 6;
     */
    value: ExpRelation;
    case: "relationDocCommentChanged";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpRelationSubjectTypeChange relation_subject_type_added = 7;
     */
    value: ExpRelationSubjectTypeChange;
    case: "relationSubjectTypeAdded";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpRelationSubjectTypeChange relation_subject_type_removed = 8;
     */
    value: ExpRelationSubjectTypeChange;
    case: "relationSubjectTypeRemoved";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpPermission permission_added = 9;
     */
    value: ExpPermission;
    case: "permissionAdded";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpPermission permission_removed = 10;
     */
    value: ExpPermission;
    case: "permissionRemoved";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpPermission permission_doc_comment_changed = 11;
     */
    value: ExpPermission;
    case: "permissionDocCommentChanged";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpPermission permission_expr_changed = 12;
     */
    value: ExpPermission;
    case: "permissionExprChanged";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpCaveat caveat_added = 13;
     */
    value: ExpCaveat;
    case: "caveatAdded";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpCaveat caveat_removed = 14;
     */
    value: ExpCaveat;
    case: "caveatRemoved";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpCaveat caveat_doc_comment_changed = 15;
     */
    value: ExpCaveat;
    case: "caveatDocCommentChanged";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpCaveat caveat_expr_changed = 16;
     */
    value: ExpCaveat;
    case: "caveatExprChanged";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpCaveatParameter caveat_parameter_added = 17;
     */
    value: ExpCaveatParameter;
    case: "caveatParameterAdded";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpCaveatParameter caveat_parameter_removed = 18;
     */
    value: ExpCaveatParameter;
    case: "caveatParameterRemoved";
  } | {
    /**
     * @generated from field: authzed.api.v1.ExpCaveatParameterTypeChange caveat_parameter_type_changed = 19;
     */
    value: ExpCaveatParameterTypeChange;
    case: "caveatParameterTypeChanged";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ExpSchemaDiff>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpSchemaDiff";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "definition_added", kind: "message", T: ExpDefinition, oneof: "diff" },
    { no: 2, name: "definition_removed", kind: "message", T: ExpDefinition, oneof: "diff" },
    { no: 3, name: "definition_doc_comment_changed", kind: "message", T: ExpDefinition, oneof: "diff" },
    { no: 4, name: "relation_added", kind: "message", T: ExpRelation, oneof: "diff" },
    { no: 5, name: "relation_removed", kind: "message", T: ExpRelation, oneof: "diff" },
    { no: 6, name: "relation_doc_comment_changed", kind: "message", T: ExpRelation, oneof: "diff" },
    { no: 7, name: "relation_subject_type_added", kind: "message", T: ExpRelationSubjectTypeChange, oneof: "diff" },
    { no: 8, name: "relation_subject_type_removed", kind: "message", T: ExpRelationSubjectTypeChange, oneof: "diff" },
    { no: 9, name: "permission_added", kind: "message", T: ExpPermission, oneof: "diff" },
    { no: 10, name: "permission_removed", kind: "message", T: ExpPermission, oneof: "diff" },
    { no: 11, name: "permission_doc_comment_changed", kind: "message", T: ExpPermission, oneof: "diff" },
    { no: 12, name: "permission_expr_changed", kind: "message", T: ExpPermission, oneof: "diff" },
    { no: 13, name: "caveat_added", kind: "message", T: ExpCaveat, oneof: "diff" },
    { no: 14, name: "caveat_removed", kind: "message", T: ExpCaveat, oneof: "diff" },
    { no: 15, name: "caveat_doc_comment_changed", kind: "message", T: ExpCaveat, oneof: "diff" },
    { no: 16, name: "caveat_expr_changed", kind: "message", T: ExpCaveat, oneof: "diff" },
    { no: 17, name: "caveat_parameter_added", kind: "message", T: ExpCaveatParameter, oneof: "diff" },
    { no: 18, name: "caveat_parameter_removed", kind: "message", T: ExpCaveatParameter, oneof: "diff" },
    { no: 19, name: "caveat_parameter_type_changed", kind: "message", T: ExpCaveatParameterTypeChange, oneof: "diff" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpSchemaDiff {
    return new ExpSchemaDiff().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpSchemaDiff {
    return new ExpSchemaDiff().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpSchemaDiff {
    return new ExpSchemaDiff().fromJsonString(jsonString, options);
  }

  static equals(a: ExpSchemaDiff | PlainMessage<ExpSchemaDiff> | undefined, b: ExpSchemaDiff | PlainMessage<ExpSchemaDiff> | undefined): boolean {
    return proto3.util.equals(ExpSchemaDiff, a, b);
  }
}

