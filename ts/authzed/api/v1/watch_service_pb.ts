// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file authzed/api/v1/watch_service.proto (package authzed.api.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Struct } from "@bufbuild/protobuf";
import { RelationshipUpdate, ZedToken } from "./core_pb.js";
import { RelationshipFilter } from "./permission_service_pb.js";

/**
 * WatchRequest specifies the object definitions for which we want to start
 * watching mutations, and an optional start snapshot for when to start
 * watching.
 *
 * @generated from message authzed.api.v1.WatchRequest
 */
export class WatchRequest extends Message<WatchRequest> {
  /**
   * optional_object_types is a filter of resource object types to watch for changes.
   * If specified, only changes to the specified object types will be returned and
   * optional_relationship_filters cannot be used.
   *
   * @generated from field: repeated string optional_object_types = 1;
   */
  optionalObjectTypes: string[] = [];

  /**
   * optional_start_cursor is the ZedToken holding the point-in-time at
   * which to start watching for changes.
   * If not specified, the watch will begin at the current head revision
   * of the datastore, returning any updates that occur after the caller
   * makes the request.
   * Note that if this cursor references a point-in-time containing data
   * that has been garbage collected, an error will be returned.
   *
   * @generated from field: authzed.api.v1.ZedToken optional_start_cursor = 2;
   */
  optionalStartCursor?: ZedToken;

  /**
   * optional_relationship_filters, if specified, indicates the
   * filter(s) to apply to each relationship to be returned by watch.
   * The relationship will be returned as long as at least one filter matches,
   * this allows clients to match relationships on multiple filters on a single watch call.
   * If specified, optional_object_types cannot be used.
   *
   * @generated from field: repeated authzed.api.v1.RelationshipFilter optional_relationship_filters = 3;
   */
  optionalRelationshipFilters: RelationshipFilter[] = [];

  constructor(data?: PartialMessage<WatchRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.WatchRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "optional_object_types", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "optional_start_cursor", kind: "message", T: ZedToken },
    { no: 3, name: "optional_relationship_filters", kind: "message", T: RelationshipFilter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WatchRequest {
    return new WatchRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WatchRequest {
    return new WatchRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WatchRequest {
    return new WatchRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WatchRequest | PlainMessage<WatchRequest> | undefined, b: WatchRequest | PlainMessage<WatchRequest> | undefined): boolean {
    return proto3.util.equals(WatchRequest, a, b);
  }
}

/**
 * WatchResponse contains all tuple modification events in ascending
 * timestamp order, from the requested start snapshot to a snapshot
 * encoded in the watch response. The client can use the snapshot to resume
 * watching where the previous watch response left off.
 *
 * @generated from message authzed.api.v1.WatchResponse
 */
export class WatchResponse extends Message<WatchResponse> {
  /**
   * updates are the RelationshipUpdate events that have occurred since the
   * last watch response.
   *
   * @generated from field: repeated authzed.api.v1.RelationshipUpdate updates = 1;
   */
  updates: RelationshipUpdate[] = [];

  /**
   * changes_through is the ZedToken that represents the point in time
   * that the watch response is current through. This token can be used
   * in a subsequent WatchRequest to resume watching from this point.
   *
   * @generated from field: authzed.api.v1.ZedToken changes_through = 2;
   */
  changesThrough?: ZedToken;

  /**
   * optional_transaction_metadata is an optional field that returns the transaction metadata
   * given to SpiceDB during the transaction that produced the changes in this response.
   * This field may not exist if no transaction metadata was provided.
   *
   * @generated from field: google.protobuf.Struct optional_transaction_metadata = 3;
   */
  optionalTransactionMetadata?: Struct;

  constructor(data?: PartialMessage<WatchResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.WatchResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "updates", kind: "message", T: RelationshipUpdate, repeated: true },
    { no: 2, name: "changes_through", kind: "message", T: ZedToken },
    { no: 3, name: "optional_transaction_metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WatchResponse {
    return new WatchResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WatchResponse {
    return new WatchResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WatchResponse {
    return new WatchResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WatchResponse | PlainMessage<WatchResponse> | undefined, b: WatchResponse | PlainMessage<WatchResponse> | undefined): boolean {
    return proto3.util.equals(WatchResponse, a, b);
  }
}

