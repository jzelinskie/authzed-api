// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file authzed/api/v1/permission_service.proto (package authzed.api.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct } from "@bufbuild/protobuf";
import { Cursor, ObjectReference, PartialCaveatInfo, PermissionRelationshipTree, Relationship, RelationshipUpdate, SubjectReference, ZedToken } from "./core_pb.js";
import { DebugInformation } from "./debug_pb.js";
import { Status } from "../../../google/rpc/status_pb.js";

/**
 * LookupPermissionship represents whether a Lookup response was partially evaluated or not
 *
 * @generated from enum authzed.api.v1.LookupPermissionship
 */
export enum LookupPermissionship {
  /**
   * @generated from enum value: LOOKUP_PERMISSIONSHIP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LOOKUP_PERMISSIONSHIP_HAS_PERMISSION = 1;
   */
  HAS_PERMISSION = 1,

  /**
   * @generated from enum value: LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION = 2;
   */
  CONDITIONAL_PERMISSION = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LookupPermissionship)
proto3.util.setEnumType(LookupPermissionship, "authzed.api.v1.LookupPermissionship", [
  { no: 0, name: "LOOKUP_PERMISSIONSHIP_UNSPECIFIED" },
  { no: 1, name: "LOOKUP_PERMISSIONSHIP_HAS_PERMISSION" },
  { no: 2, name: "LOOKUP_PERMISSIONSHIP_CONDITIONAL_PERMISSION" },
]);

/**
 * Consistency will define how a request is handled by the backend.
 * By defining a consistency requirement, and a token at which those
 * requirements should be applied, where applicable.
 *
 * @generated from message authzed.api.v1.Consistency
 */
export class Consistency extends Message<Consistency> {
  /**
   * @generated from oneof authzed.api.v1.Consistency.requirement
   */
  requirement: {
    /**
     * minimize_latency indicates that the latency for the call should be
     * minimized by having the system select the fastest snapshot available.
     *
     * @generated from field: bool minimize_latency = 1;
     */
    value: boolean;
    case: "minimizeLatency";
  } | {
    /**
     * at_least_as_fresh indicates that all data used in the API call must be
     * *at least as fresh* as that found in the ZedToken; more recent data might
     * be used if available or faster.
     *
     * @generated from field: authzed.api.v1.ZedToken at_least_as_fresh = 2;
     */
    value: ZedToken;
    case: "atLeastAsFresh";
  } | {
    /**
     * at_exact_snapshot indicates that all data used in the API call must be
     * *at the given* snapshot in time; if the snapshot is no longer available,
     * an error will be returned to the caller.
     *
     * @generated from field: authzed.api.v1.ZedToken at_exact_snapshot = 3;
     */
    value: ZedToken;
    case: "atExactSnapshot";
  } | {
    /**
     * fully_consistent indicates that all data used in the API call *must* be
     * at the most recent snapshot found.
     *
     * NOTE: using this method can be *quite slow*, so unless there is a need to
     * do so, it is recommended to use `at_least_as_fresh` with a stored
     * ZedToken.
     *
     * @generated from field: bool fully_consistent = 4;
     */
    value: boolean;
    case: "fullyConsistent";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Consistency>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.Consistency";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "minimize_latency", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "requirement" },
    { no: 2, name: "at_least_as_fresh", kind: "message", T: ZedToken, oneof: "requirement" },
    { no: 3, name: "at_exact_snapshot", kind: "message", T: ZedToken, oneof: "requirement" },
    { no: 4, name: "fully_consistent", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "requirement" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Consistency {
    return new Consistency().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Consistency {
    return new Consistency().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Consistency {
    return new Consistency().fromJsonString(jsonString, options);
  }

  static equals(a: Consistency | PlainMessage<Consistency> | undefined, b: Consistency | PlainMessage<Consistency> | undefined): boolean {
    return proto3.util.equals(Consistency, a, b);
  }
}

/**
 * RelationshipFilter is a collection of filters which when applied to a
 * relationship will return relationships that have exactly matching fields.
 *
 * All fields are optional and if left unspecified will not filter relationships,
 * but at least one field must be specified.
 *
 * NOTE: The performance of the API will be affected by the selection of fields
 * on which to filter. If a field is not indexed, the performance of the API
 * can be significantly slower.
 *
 * @generated from message authzed.api.v1.RelationshipFilter
 */
export class RelationshipFilter extends Message<RelationshipFilter> {
  /**
   * resource_type is the *optional* resource type of the relationship.
   * NOTE: It is not prefixed with "optional_" for legacy compatibility.
   *
   * @generated from field: string resource_type = 1;
   */
  resourceType = "";

  /**
   * optional_resource_id is the *optional* resource ID of the relationship.
   * If specified, optional_resource_id_prefix cannot be specified.
   *
   * @generated from field: string optional_resource_id = 2;
   */
  optionalResourceId = "";

  /**
   * optional_resource_id_prefix is the *optional* prefix for the resource ID of the relationship.
   * If specified, optional_resource_id cannot be specified.
   *
   * @generated from field: string optional_resource_id_prefix = 5;
   */
  optionalResourceIdPrefix = "";

  /**
   * relation is the *optional* relation of the relationship.
   *
   * @generated from field: string optional_relation = 3;
   */
  optionalRelation = "";

  /**
   * optional_subject_filter is the optional filter for the subjects of the relationships.
   *
   * @generated from field: authzed.api.v1.SubjectFilter optional_subject_filter = 4;
   */
  optionalSubjectFilter?: SubjectFilter;

  constructor(data?: PartialMessage<RelationshipFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.RelationshipFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "optional_resource_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "optional_resource_id_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "optional_relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "optional_subject_filter", kind: "message", T: SubjectFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipFilter {
    return new RelationshipFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipFilter {
    return new RelationshipFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipFilter {
    return new RelationshipFilter().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipFilter | PlainMessage<RelationshipFilter> | undefined, b: RelationshipFilter | PlainMessage<RelationshipFilter> | undefined): boolean {
    return proto3.util.equals(RelationshipFilter, a, b);
  }
}

/**
 * SubjectFilter specifies a filter on the subject of a relationship.
 *
 * subject_type is required and all other fields are optional, and will not
 * impose any additional requirements if left unspecified.
 *
 * @generated from message authzed.api.v1.SubjectFilter
 */
export class SubjectFilter extends Message<SubjectFilter> {
  /**
   * @generated from field: string subject_type = 1;
   */
  subjectType = "";

  /**
   * @generated from field: string optional_subject_id = 2;
   */
  optionalSubjectId = "";

  /**
   * @generated from field: authzed.api.v1.SubjectFilter.RelationFilter optional_relation = 3;
   */
  optionalRelation?: SubjectFilter_RelationFilter;

  constructor(data?: PartialMessage<SubjectFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.SubjectFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subject_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "optional_subject_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "optional_relation", kind: "message", T: SubjectFilter_RelationFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectFilter {
    return new SubjectFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectFilter {
    return new SubjectFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectFilter {
    return new SubjectFilter().fromJsonString(jsonString, options);
  }

  static equals(a: SubjectFilter | PlainMessage<SubjectFilter> | undefined, b: SubjectFilter | PlainMessage<SubjectFilter> | undefined): boolean {
    return proto3.util.equals(SubjectFilter, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.SubjectFilter.RelationFilter
 */
export class SubjectFilter_RelationFilter extends Message<SubjectFilter_RelationFilter> {
  /**
   * @generated from field: string relation = 1;
   */
  relation = "";

  constructor(data?: PartialMessage<SubjectFilter_RelationFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.SubjectFilter.RelationFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectFilter_RelationFilter {
    return new SubjectFilter_RelationFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectFilter_RelationFilter {
    return new SubjectFilter_RelationFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectFilter_RelationFilter {
    return new SubjectFilter_RelationFilter().fromJsonString(jsonString, options);
  }

  static equals(a: SubjectFilter_RelationFilter | PlainMessage<SubjectFilter_RelationFilter> | undefined, b: SubjectFilter_RelationFilter | PlainMessage<SubjectFilter_RelationFilter> | undefined): boolean {
    return proto3.util.equals(SubjectFilter_RelationFilter, a, b);
  }
}

/**
 * ReadRelationshipsRequest specifies one or more filters used to read matching
 * relationships within the system.
 *
 * @generated from message authzed.api.v1.ReadRelationshipsRequest
 */
export class ReadRelationshipsRequest extends Message<ReadRelationshipsRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * relationship_filter defines the filter to be applied to the relationships
   * to be returned.
   *
   * @generated from field: authzed.api.v1.RelationshipFilter relationship_filter = 2;
   */
  relationshipFilter?: RelationshipFilter;

  /**
   * optional_limit, if non-zero, specifies the limit on the number of relationships to return
   * before the stream is closed on the server side. By default, the stream will continue
   * resolving relationships until exhausted or the stream is closed due to the client or a
   * network issue.
   *
   * @generated from field: uint32 optional_limit = 3;
   */
  optionalLimit = 0;

  /**
   * optional_cursor, if specified, indicates the cursor after which results should resume being returned.
   * The cursor can be found on the ReadRelationshipsResponse object.
   *
   * @generated from field: authzed.api.v1.Cursor optional_cursor = 4;
   */
  optionalCursor?: Cursor;

  constructor(data?: PartialMessage<ReadRelationshipsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ReadRelationshipsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "relationship_filter", kind: "message", T: RelationshipFilter },
    { no: 3, name: "optional_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "optional_cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRelationshipsRequest {
    return new ReadRelationshipsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRelationshipsRequest {
    return new ReadRelationshipsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRelationshipsRequest {
    return new ReadRelationshipsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRelationshipsRequest | PlainMessage<ReadRelationshipsRequest> | undefined, b: ReadRelationshipsRequest | PlainMessage<ReadRelationshipsRequest> | undefined): boolean {
    return proto3.util.equals(ReadRelationshipsRequest, a, b);
  }
}

/**
 * ReadRelationshipsResponse contains a Relationship found that matches the
 * specified relationship filter(s). A instance of this response message will
 * be streamed to the client for each relationship found.
 *
 * @generated from message authzed.api.v1.ReadRelationshipsResponse
 */
export class ReadRelationshipsResponse extends Message<ReadRelationshipsResponse> {
  /**
   * read_at is the ZedToken at which the relationship was found.
   *
   * @generated from field: authzed.api.v1.ZedToken read_at = 1;
   */
  readAt?: ZedToken;

  /**
   * relationship is the found relationship.
   *
   * @generated from field: authzed.api.v1.Relationship relationship = 2;
   */
  relationship?: Relationship;

  /**
   * after_result_cursor holds a cursor that can be used to resume the ReadRelationships stream after this
   * result.
   *
   * @generated from field: authzed.api.v1.Cursor after_result_cursor = 3;
   */
  afterResultCursor?: Cursor;

  constructor(data?: PartialMessage<ReadRelationshipsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ReadRelationshipsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_at", kind: "message", T: ZedToken },
    { no: 2, name: "relationship", kind: "message", T: Relationship },
    { no: 3, name: "after_result_cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRelationshipsResponse {
    return new ReadRelationshipsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRelationshipsResponse {
    return new ReadRelationshipsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRelationshipsResponse {
    return new ReadRelationshipsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRelationshipsResponse | PlainMessage<ReadRelationshipsResponse> | undefined, b: ReadRelationshipsResponse | PlainMessage<ReadRelationshipsResponse> | undefined): boolean {
    return proto3.util.equals(ReadRelationshipsResponse, a, b);
  }
}

/**
 * Precondition specifies how and the existence or absence of certain
 * relationships as expressed through the accompanying filter should affect
 * whether or not the operation proceeds.
 *
 * MUST_NOT_MATCH will fail the parent request if any relationships match the
 * relationships filter.
 * MUST_MATCH will fail the parent request if there are no
 * relationships that match the filter.
 *
 * @generated from message authzed.api.v1.Precondition
 */
export class Precondition extends Message<Precondition> {
  /**
   * @generated from field: authzed.api.v1.Precondition.Operation operation = 1;
   */
  operation = Precondition_Operation.UNSPECIFIED;

  /**
   * @generated from field: authzed.api.v1.RelationshipFilter filter = 2;
   */
  filter?: RelationshipFilter;

  constructor(data?: PartialMessage<Precondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.Precondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation", kind: "enum", T: proto3.getEnumType(Precondition_Operation) },
    { no: 2, name: "filter", kind: "message", T: RelationshipFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Precondition {
    return new Precondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Precondition {
    return new Precondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Precondition {
    return new Precondition().fromJsonString(jsonString, options);
  }

  static equals(a: Precondition | PlainMessage<Precondition> | undefined, b: Precondition | PlainMessage<Precondition> | undefined): boolean {
    return proto3.util.equals(Precondition, a, b);
  }
}

/**
 * @generated from enum authzed.api.v1.Precondition.Operation
 */
export enum Precondition_Operation {
  /**
   * @generated from enum value: OPERATION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OPERATION_MUST_NOT_MATCH = 1;
   */
  MUST_NOT_MATCH = 1,

  /**
   * @generated from enum value: OPERATION_MUST_MATCH = 2;
   */
  MUST_MATCH = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Precondition_Operation)
proto3.util.setEnumType(Precondition_Operation, "authzed.api.v1.Precondition.Operation", [
  { no: 0, name: "OPERATION_UNSPECIFIED" },
  { no: 1, name: "OPERATION_MUST_NOT_MATCH" },
  { no: 2, name: "OPERATION_MUST_MATCH" },
]);

/**
 * WriteRelationshipsRequest contains a list of Relationship mutations that
 * should be applied to the service. If the optional_preconditions parameter
 * is included, all of the specified preconditions must also be satisfied before
 * the write will be committed. All updates will be applied transactionally,
 * and if any preconditions fail, the entire transaction will be reverted.
 *
 * @generated from message authzed.api.v1.WriteRelationshipsRequest
 */
export class WriteRelationshipsRequest extends Message<WriteRelationshipsRequest> {
  /**
   * @generated from field: repeated authzed.api.v1.RelationshipUpdate updates = 1;
   */
  updates: RelationshipUpdate[] = [];

  /**
   * To be bounded by configuration
   *
   * @generated from field: repeated authzed.api.v1.Precondition optional_preconditions = 2;
   */
  optionalPreconditions: Precondition[] = [];

  /**
   * optional_transaction_metadata is an optional field that can be used to store metadata about the transaction.
   * If specified, this metadata will be supplied in the WatchResponse for the updates associated with this
   * transaction.
   *
   * @generated from field: google.protobuf.Struct optional_transaction_metadata = 3;
   */
  optionalTransactionMetadata?: Struct;

  constructor(data?: PartialMessage<WriteRelationshipsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.WriteRelationshipsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "updates", kind: "message", T: RelationshipUpdate, repeated: true },
    { no: 2, name: "optional_preconditions", kind: "message", T: Precondition, repeated: true },
    { no: 3, name: "optional_transaction_metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteRelationshipsRequest {
    return new WriteRelationshipsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteRelationshipsRequest {
    return new WriteRelationshipsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteRelationshipsRequest {
    return new WriteRelationshipsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WriteRelationshipsRequest | PlainMessage<WriteRelationshipsRequest> | undefined, b: WriteRelationshipsRequest | PlainMessage<WriteRelationshipsRequest> | undefined): boolean {
    return proto3.util.equals(WriteRelationshipsRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.WriteRelationshipsResponse
 */
export class WriteRelationshipsResponse extends Message<WriteRelationshipsResponse> {
  /**
   * @generated from field: authzed.api.v1.ZedToken written_at = 1;
   */
  writtenAt?: ZedToken;

  constructor(data?: PartialMessage<WriteRelationshipsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.WriteRelationshipsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "written_at", kind: "message", T: ZedToken },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteRelationshipsResponse {
    return new WriteRelationshipsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteRelationshipsResponse {
    return new WriteRelationshipsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteRelationshipsResponse {
    return new WriteRelationshipsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WriteRelationshipsResponse | PlainMessage<WriteRelationshipsResponse> | undefined, b: WriteRelationshipsResponse | PlainMessage<WriteRelationshipsResponse> | undefined): boolean {
    return proto3.util.equals(WriteRelationshipsResponse, a, b);
  }
}

/**
 * DeleteRelationshipsRequest specifies which Relationships should be deleted,
 * requesting the delete of *ALL* relationships that match the specified
 * filters. If the optional_preconditions parameter is included, all of the
 * specified preconditions must also be satisfied before the delete will be
 * executed.
 *
 * @generated from message authzed.api.v1.DeleteRelationshipsRequest
 */
export class DeleteRelationshipsRequest extends Message<DeleteRelationshipsRequest> {
  /**
   * @generated from field: authzed.api.v1.RelationshipFilter relationship_filter = 1;
   */
  relationshipFilter?: RelationshipFilter;

  /**
   * To be bounded by configuration
   *
   * @generated from field: repeated authzed.api.v1.Precondition optional_preconditions = 2;
   */
  optionalPreconditions: Precondition[] = [];

  /**
   * optional_limit, if non-zero, specifies the limit on the number of relationships to be deleted.
   * If there are more matching relationships found to be deleted than the limit specified here,
   * the deletion call will fail with an error to prevent partial deletion. If partial deletion
   * is needed, specify below that partial deletion is allowed. Partial deletions can be used
   * in a loop to delete large amounts of relationships in a *non-transactional* manner.
   *
   * @generated from field: uint32 optional_limit = 3;
   */
  optionalLimit = 0;

  /**
   * optional_allow_partial_deletions, if true and a limit is specified, will delete matching found
   * relationships up to the count specified in optional_limit, and no more.
   *
   * @generated from field: bool optional_allow_partial_deletions = 4;
   */
  optionalAllowPartialDeletions = false;

  /**
   * optional_transaction_metadata is an optional field that can be used to store metadata about the transaction.
   * If specified, this metadata will be supplied in the WatchResponse for the deletions associated with
   * this transaction.
   *
   * @generated from field: google.protobuf.Struct optional_transaction_metadata = 5;
   */
  optionalTransactionMetadata?: Struct;

  constructor(data?: PartialMessage<DeleteRelationshipsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.DeleteRelationshipsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relationship_filter", kind: "message", T: RelationshipFilter },
    { no: 2, name: "optional_preconditions", kind: "message", T: Precondition, repeated: true },
    { no: 3, name: "optional_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 4, name: "optional_allow_partial_deletions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "optional_transaction_metadata", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteRelationshipsRequest {
    return new DeleteRelationshipsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteRelationshipsRequest {
    return new DeleteRelationshipsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteRelationshipsRequest {
    return new DeleteRelationshipsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteRelationshipsRequest | PlainMessage<DeleteRelationshipsRequest> | undefined, b: DeleteRelationshipsRequest | PlainMessage<DeleteRelationshipsRequest> | undefined): boolean {
    return proto3.util.equals(DeleteRelationshipsRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.DeleteRelationshipsResponse
 */
export class DeleteRelationshipsResponse extends Message<DeleteRelationshipsResponse> {
  /**
   * deleted_at is the revision at which the relationships were deleted.
   *
   * @generated from field: authzed.api.v1.ZedToken deleted_at = 1;
   */
  deletedAt?: ZedToken;

  /**
   * deletion_progress is an enumeration of the possible outcomes that occurred when attempting to delete the specified relationships.
   *
   * @generated from field: authzed.api.v1.DeleteRelationshipsResponse.DeletionProgress deletion_progress = 2;
   */
  deletionProgress = DeleteRelationshipsResponse_DeletionProgress.UNSPECIFIED;

  constructor(data?: PartialMessage<DeleteRelationshipsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.DeleteRelationshipsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deleted_at", kind: "message", T: ZedToken },
    { no: 2, name: "deletion_progress", kind: "enum", T: proto3.getEnumType(DeleteRelationshipsResponse_DeletionProgress) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteRelationshipsResponse {
    return new DeleteRelationshipsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteRelationshipsResponse {
    return new DeleteRelationshipsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteRelationshipsResponse {
    return new DeleteRelationshipsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteRelationshipsResponse | PlainMessage<DeleteRelationshipsResponse> | undefined, b: DeleteRelationshipsResponse | PlainMessage<DeleteRelationshipsResponse> | undefined): boolean {
    return proto3.util.equals(DeleteRelationshipsResponse, a, b);
  }
}

/**
 * @generated from enum authzed.api.v1.DeleteRelationshipsResponse.DeletionProgress
 */
export enum DeleteRelationshipsResponse_DeletionProgress {
  /**
   * @generated from enum value: DELETION_PROGRESS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * DELETION_PROGRESS_COMPLETE indicates that all remaining relationships matching the filter
   * were deleted. Will be returned even if no relationships were deleted.
   *
   * @generated from enum value: DELETION_PROGRESS_COMPLETE = 1;
   */
  COMPLETE = 1,

  /**
   * DELETION_PROGRESS_PARTIAL indicates that a subset of the relationships matching the filter
   * were deleted. Only returned if optional_allow_partial_deletions was true, an optional_limit was
   * specified, and there existed more relationships matching the filter than optional_limit would allow.
   * Once all remaining relationships have been deleted, DELETION_PROGRESS_COMPLETE will be returned.
   *
   * @generated from enum value: DELETION_PROGRESS_PARTIAL = 2;
   */
  PARTIAL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DeleteRelationshipsResponse_DeletionProgress)
proto3.util.setEnumType(DeleteRelationshipsResponse_DeletionProgress, "authzed.api.v1.DeleteRelationshipsResponse.DeletionProgress", [
  { no: 0, name: "DELETION_PROGRESS_UNSPECIFIED" },
  { no: 1, name: "DELETION_PROGRESS_COMPLETE" },
  { no: 2, name: "DELETION_PROGRESS_PARTIAL" },
]);

/**
 * CheckPermissionRequest issues a check on whether a subject has a permission
 * or is a member of a relation, on a specific resource.
 *
 * @generated from message authzed.api.v1.CheckPermissionRequest
 */
export class CheckPermissionRequest extends Message<CheckPermissionRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * resource is the resource on which to check the permission or relation.
   *
   * @generated from field: authzed.api.v1.ObjectReference resource = 2;
   */
  resource?: ObjectReference;

  /**
   * permission is the name of the permission (or relation) on which to execute
   * the check.
   *
   * @generated from field: string permission = 3;
   */
  permission = "";

  /**
   * subject is the subject that will be checked for the permission or relation.
   *
   * @generated from field: authzed.api.v1.SubjectReference subject = 4;
   */
  subject?: SubjectReference;

  /**
   * context consists of named values that are injected into the caveat evaluation context
   *
   * @generated from field: google.protobuf.Struct context = 5;
   */
  context?: Struct;

  /**
   * with_tracing, if true, indicates that the response should include a debug trace.
   * This can be useful for debugging and performance analysis, but adds a small amount
   * of compute overhead to the request.
   *
   * @generated from field: bool with_tracing = 6;
   */
  withTracing = false;

  constructor(data?: PartialMessage<CheckPermissionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.CheckPermissionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "resource", kind: "message", T: ObjectReference },
    { no: 3, name: "permission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "subject", kind: "message", T: SubjectReference },
    { no: 5, name: "context", kind: "message", T: Struct },
    { no: 6, name: "with_tracing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckPermissionRequest {
    return new CheckPermissionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckPermissionRequest {
    return new CheckPermissionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckPermissionRequest {
    return new CheckPermissionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckPermissionRequest | PlainMessage<CheckPermissionRequest> | undefined, b: CheckPermissionRequest | PlainMessage<CheckPermissionRequest> | undefined): boolean {
    return proto3.util.equals(CheckPermissionRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.CheckPermissionResponse
 */
export class CheckPermissionResponse extends Message<CheckPermissionResponse> {
  /**
   * @generated from field: authzed.api.v1.ZedToken checked_at = 1;
   */
  checkedAt?: ZedToken;

  /**
   * Permissionship communicates whether or not the subject has the requested
   * permission or has a relationship with the given resource, over the given
   * relation.
   *
   * This value will be authzed.api.v1.PERMISSIONSHIP_HAS_PERMISSION if the
   * requested subject is a member of the computed permission set or there
   * exists a relationship with the requested relation from the given resource
   * to the given subject.
   *
   * @generated from field: authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 2;
   */
  permissionship = CheckPermissionResponse_Permissionship.UNSPECIFIED;

  /**
   * partial_caveat_info holds information of a partially-evaluated caveated response
   *
   * @generated from field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3;
   */
  partialCaveatInfo?: PartialCaveatInfo;

  /**
   * debug_trace is the debugging trace of this check, if requested.
   *
   * @generated from field: authzed.api.v1.DebugInformation debug_trace = 4;
   */
  debugTrace?: DebugInformation;

  constructor(data?: PartialMessage<CheckPermissionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.CheckPermissionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checked_at", kind: "message", T: ZedToken },
    { no: 2, name: "permissionship", kind: "enum", T: proto3.getEnumType(CheckPermissionResponse_Permissionship) },
    { no: 3, name: "partial_caveat_info", kind: "message", T: PartialCaveatInfo },
    { no: 4, name: "debug_trace", kind: "message", T: DebugInformation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckPermissionResponse {
    return new CheckPermissionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckPermissionResponse {
    return new CheckPermissionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckPermissionResponse {
    return new CheckPermissionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckPermissionResponse | PlainMessage<CheckPermissionResponse> | undefined, b: CheckPermissionResponse | PlainMessage<CheckPermissionResponse> | undefined): boolean {
    return proto3.util.equals(CheckPermissionResponse, a, b);
  }
}

/**
 * @generated from enum authzed.api.v1.CheckPermissionResponse.Permissionship
 */
export enum CheckPermissionResponse_Permissionship {
  /**
   * @generated from enum value: PERMISSIONSHIP_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PERMISSIONSHIP_NO_PERMISSION = 1;
   */
  NO_PERMISSION = 1,

  /**
   * @generated from enum value: PERMISSIONSHIP_HAS_PERMISSION = 2;
   */
  HAS_PERMISSION = 2,

  /**
   * @generated from enum value: PERMISSIONSHIP_CONDITIONAL_PERMISSION = 3;
   */
  CONDITIONAL_PERMISSION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(CheckPermissionResponse_Permissionship)
proto3.util.setEnumType(CheckPermissionResponse_Permissionship, "authzed.api.v1.CheckPermissionResponse.Permissionship", [
  { no: 0, name: "PERMISSIONSHIP_UNSPECIFIED" },
  { no: 1, name: "PERMISSIONSHIP_NO_PERMISSION" },
  { no: 2, name: "PERMISSIONSHIP_HAS_PERMISSION" },
  { no: 3, name: "PERMISSIONSHIP_CONDITIONAL_PERMISSION" },
]);

/**
 * CheckBulkPermissionsRequest issues a check on whether a subject has permission 
 * or is a member of a relation on a specific resource for each item in the list.
 *
 * The ordering of the items in the response is maintained in the response.
 * Checks with the same subject/permission will automatically be batched for performance optimization.
 *
 * @generated from message authzed.api.v1.CheckBulkPermissionsRequest
 */
export class CheckBulkPermissionsRequest extends Message<CheckBulkPermissionsRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * @generated from field: repeated authzed.api.v1.CheckBulkPermissionsRequestItem items = 2;
   */
  items: CheckBulkPermissionsRequestItem[] = [];

  constructor(data?: PartialMessage<CheckBulkPermissionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.CheckBulkPermissionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "items", kind: "message", T: CheckBulkPermissionsRequestItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckBulkPermissionsRequest {
    return new CheckBulkPermissionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckBulkPermissionsRequest {
    return new CheckBulkPermissionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckBulkPermissionsRequest {
    return new CheckBulkPermissionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckBulkPermissionsRequest | PlainMessage<CheckBulkPermissionsRequest> | undefined, b: CheckBulkPermissionsRequest | PlainMessage<CheckBulkPermissionsRequest> | undefined): boolean {
    return proto3.util.equals(CheckBulkPermissionsRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.CheckBulkPermissionsRequestItem
 */
export class CheckBulkPermissionsRequestItem extends Message<CheckBulkPermissionsRequestItem> {
  /**
   * @generated from field: authzed.api.v1.ObjectReference resource = 1;
   */
  resource?: ObjectReference;

  /**
   * @generated from field: string permission = 2;
   */
  permission = "";

  /**
   * @generated from field: authzed.api.v1.SubjectReference subject = 3;
   */
  subject?: SubjectReference;

  /**
   * @generated from field: google.protobuf.Struct context = 4;
   */
  context?: Struct;

  constructor(data?: PartialMessage<CheckBulkPermissionsRequestItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.CheckBulkPermissionsRequestItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: ObjectReference },
    { no: 2, name: "permission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subject", kind: "message", T: SubjectReference },
    { no: 4, name: "context", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckBulkPermissionsRequestItem {
    return new CheckBulkPermissionsRequestItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckBulkPermissionsRequestItem {
    return new CheckBulkPermissionsRequestItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckBulkPermissionsRequestItem {
    return new CheckBulkPermissionsRequestItem().fromJsonString(jsonString, options);
  }

  static equals(a: CheckBulkPermissionsRequestItem | PlainMessage<CheckBulkPermissionsRequestItem> | undefined, b: CheckBulkPermissionsRequestItem | PlainMessage<CheckBulkPermissionsRequestItem> | undefined): boolean {
    return proto3.util.equals(CheckBulkPermissionsRequestItem, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.CheckBulkPermissionsResponse
 */
export class CheckBulkPermissionsResponse extends Message<CheckBulkPermissionsResponse> {
  /**
   * @generated from field: authzed.api.v1.ZedToken checked_at = 1;
   */
  checkedAt?: ZedToken;

  /**
   * @generated from field: repeated authzed.api.v1.CheckBulkPermissionsPair pairs = 2;
   */
  pairs: CheckBulkPermissionsPair[] = [];

  constructor(data?: PartialMessage<CheckBulkPermissionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.CheckBulkPermissionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "checked_at", kind: "message", T: ZedToken },
    { no: 2, name: "pairs", kind: "message", T: CheckBulkPermissionsPair, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckBulkPermissionsResponse {
    return new CheckBulkPermissionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckBulkPermissionsResponse {
    return new CheckBulkPermissionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckBulkPermissionsResponse {
    return new CheckBulkPermissionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckBulkPermissionsResponse | PlainMessage<CheckBulkPermissionsResponse> | undefined, b: CheckBulkPermissionsResponse | PlainMessage<CheckBulkPermissionsResponse> | undefined): boolean {
    return proto3.util.equals(CheckBulkPermissionsResponse, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.CheckBulkPermissionsPair
 */
export class CheckBulkPermissionsPair extends Message<CheckBulkPermissionsPair> {
  /**
   * @generated from field: authzed.api.v1.CheckBulkPermissionsRequestItem request = 1;
   */
  request?: CheckBulkPermissionsRequestItem;

  /**
   * @generated from oneof authzed.api.v1.CheckBulkPermissionsPair.response
   */
  response: {
    /**
     * @generated from field: authzed.api.v1.CheckBulkPermissionsResponseItem item = 2;
     */
    value: CheckBulkPermissionsResponseItem;
    case: "item";
  } | {
    /**
     * @generated from field: google.rpc.Status error = 3;
     */
    value: Status;
    case: "error";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CheckBulkPermissionsPair>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.CheckBulkPermissionsPair";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "request", kind: "message", T: CheckBulkPermissionsRequestItem },
    { no: 2, name: "item", kind: "message", T: CheckBulkPermissionsResponseItem, oneof: "response" },
    { no: 3, name: "error", kind: "message", T: Status, oneof: "response" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckBulkPermissionsPair {
    return new CheckBulkPermissionsPair().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckBulkPermissionsPair {
    return new CheckBulkPermissionsPair().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckBulkPermissionsPair {
    return new CheckBulkPermissionsPair().fromJsonString(jsonString, options);
  }

  static equals(a: CheckBulkPermissionsPair | PlainMessage<CheckBulkPermissionsPair> | undefined, b: CheckBulkPermissionsPair | PlainMessage<CheckBulkPermissionsPair> | undefined): boolean {
    return proto3.util.equals(CheckBulkPermissionsPair, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.CheckBulkPermissionsResponseItem
 */
export class CheckBulkPermissionsResponseItem extends Message<CheckBulkPermissionsResponseItem> {
  /**
   * @generated from field: authzed.api.v1.CheckPermissionResponse.Permissionship permissionship = 1;
   */
  permissionship = CheckPermissionResponse_Permissionship.UNSPECIFIED;

  /**
   * @generated from field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 2;
   */
  partialCaveatInfo?: PartialCaveatInfo;

  constructor(data?: PartialMessage<CheckBulkPermissionsResponseItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.CheckBulkPermissionsResponseItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "permissionship", kind: "enum", T: proto3.getEnumType(CheckPermissionResponse_Permissionship) },
    { no: 2, name: "partial_caveat_info", kind: "message", T: PartialCaveatInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckBulkPermissionsResponseItem {
    return new CheckBulkPermissionsResponseItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckBulkPermissionsResponseItem {
    return new CheckBulkPermissionsResponseItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckBulkPermissionsResponseItem {
    return new CheckBulkPermissionsResponseItem().fromJsonString(jsonString, options);
  }

  static equals(a: CheckBulkPermissionsResponseItem | PlainMessage<CheckBulkPermissionsResponseItem> | undefined, b: CheckBulkPermissionsResponseItem | PlainMessage<CheckBulkPermissionsResponseItem> | undefined): boolean {
    return proto3.util.equals(CheckBulkPermissionsResponseItem, a, b);
  }
}

/**
 * ExpandPermissionTreeRequest returns a tree representing the expansion of all
 * relationships found accessible from a permission or relation on a particular
 * resource.
 *
 * ExpandPermissionTreeRequest is typically used to determine the full set of
 * subjects with a permission, along with the relationships that grant said
 * access.
 *
 * @generated from message authzed.api.v1.ExpandPermissionTreeRequest
 */
export class ExpandPermissionTreeRequest extends Message<ExpandPermissionTreeRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * resource is the resource over which to run the expansion.
   *
   * @generated from field: authzed.api.v1.ObjectReference resource = 2;
   */
  resource?: ObjectReference;

  /**
   * permission is the name of the permission or relation over which to run the
   * expansion for the resource.
   *
   * @generated from field: string permission = 3;
   */
  permission = "";

  constructor(data?: PartialMessage<ExpandPermissionTreeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpandPermissionTreeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "resource", kind: "message", T: ObjectReference },
    { no: 3, name: "permission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpandPermissionTreeRequest {
    return new ExpandPermissionTreeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpandPermissionTreeRequest {
    return new ExpandPermissionTreeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpandPermissionTreeRequest {
    return new ExpandPermissionTreeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExpandPermissionTreeRequest | PlainMessage<ExpandPermissionTreeRequest> | undefined, b: ExpandPermissionTreeRequest | PlainMessage<ExpandPermissionTreeRequest> | undefined): boolean {
    return proto3.util.equals(ExpandPermissionTreeRequest, a, b);
  }
}

/**
 * @generated from message authzed.api.v1.ExpandPermissionTreeResponse
 */
export class ExpandPermissionTreeResponse extends Message<ExpandPermissionTreeResponse> {
  /**
   * @generated from field: authzed.api.v1.ZedToken expanded_at = 1;
   */
  expandedAt?: ZedToken;

  /**
   * tree_root is a tree structure whose leaf nodes are subjects, and
   * intermediate nodes represent the various operations (union, intersection,
   * exclusion) to reach those subjects.
   *
   * @generated from field: authzed.api.v1.PermissionRelationshipTree tree_root = 2;
   */
  treeRoot?: PermissionRelationshipTree;

  constructor(data?: PartialMessage<ExpandPermissionTreeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExpandPermissionTreeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expanded_at", kind: "message", T: ZedToken },
    { no: 2, name: "tree_root", kind: "message", T: PermissionRelationshipTree },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExpandPermissionTreeResponse {
    return new ExpandPermissionTreeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExpandPermissionTreeResponse {
    return new ExpandPermissionTreeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExpandPermissionTreeResponse {
    return new ExpandPermissionTreeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExpandPermissionTreeResponse | PlainMessage<ExpandPermissionTreeResponse> | undefined, b: ExpandPermissionTreeResponse | PlainMessage<ExpandPermissionTreeResponse> | undefined): boolean {
    return proto3.util.equals(ExpandPermissionTreeResponse, a, b);
  }
}

/**
 * LookupResourcesRequest performs a lookup of all resources of a particular
 * kind on which the subject has the specified permission or the relation in
 * which the subject exists, streaming back the IDs of those resources.
 *
 * @generated from message authzed.api.v1.LookupResourcesRequest
 */
export class LookupResourcesRequest extends Message<LookupResourcesRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * resource_object_type is the type of resource object for which the IDs will
   * be returned.
   *
   * @generated from field: string resource_object_type = 2;
   */
  resourceObjectType = "";

  /**
   * permission is the name of the permission or relation for which the subject
   * must Check.
   *
   * @generated from field: string permission = 3;
   */
  permission = "";

  /**
   * subject is the subject with access to the resources.
   *
   * @generated from field: authzed.api.v1.SubjectReference subject = 4;
   */
  subject?: SubjectReference;

  /**
   * context consists of named values that are injected into the caveat evaluation context
   *
   * @generated from field: google.protobuf.Struct context = 5;
   */
  context?: Struct;

  /**
   * optional_limit, if non-zero, specifies the limit on the number of resources to return
   * before the stream is closed on the server side. By default, the stream will continue
   * resolving resources until exhausted or the stream is closed due to the client or a
   * network issue.
   *
   * @generated from field: uint32 optional_limit = 6;
   */
  optionalLimit = 0;

  /**
   * optional_cursor, if specified, indicates the cursor after which results should resume being returned.
   * The cursor can be found on the LookupResourcesResponse object.
   *
   * @generated from field: authzed.api.v1.Cursor optional_cursor = 7;
   */
  optionalCursor?: Cursor;

  constructor(data?: PartialMessage<LookupResourcesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.LookupResourcesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "resource_object_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "permission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "subject", kind: "message", T: SubjectReference },
    { no: 5, name: "context", kind: "message", T: Struct },
    { no: 6, name: "optional_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "optional_cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupResourcesRequest {
    return new LookupResourcesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupResourcesRequest {
    return new LookupResourcesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupResourcesRequest {
    return new LookupResourcesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LookupResourcesRequest | PlainMessage<LookupResourcesRequest> | undefined, b: LookupResourcesRequest | PlainMessage<LookupResourcesRequest> | undefined): boolean {
    return proto3.util.equals(LookupResourcesRequest, a, b);
  }
}

/**
 * LookupResourcesResponse contains a single matching resource object ID for the
 * requested object type, permission, and subject.
 *
 * @generated from message authzed.api.v1.LookupResourcesResponse
 */
export class LookupResourcesResponse extends Message<LookupResourcesResponse> {
  /**
   * looked_up_at is the ZedToken at which the resource was found.
   *
   * @generated from field: authzed.api.v1.ZedToken looked_up_at = 1;
   */
  lookedUpAt?: ZedToken;

  /**
   * resource_object_id is the object ID of the found resource.
   *
   * @generated from field: string resource_object_id = 2;
   */
  resourceObjectId = "";

  /**
   * permissionship indicates whether the response was partially evaluated or not
   *
   * @generated from field: authzed.api.v1.LookupPermissionship permissionship = 3;
   */
  permissionship = LookupPermissionship.UNSPECIFIED;

  /**
   * partial_caveat_info holds information of a partially-evaluated caveated response
   *
   * @generated from field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 4;
   */
  partialCaveatInfo?: PartialCaveatInfo;

  /**
   * after_result_cursor holds a cursor that can be used to resume the LookupResources stream after this
   * result.
   *
   * @generated from field: authzed.api.v1.Cursor after_result_cursor = 5;
   */
  afterResultCursor?: Cursor;

  constructor(data?: PartialMessage<LookupResourcesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.LookupResourcesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "looked_up_at", kind: "message", T: ZedToken },
    { no: 2, name: "resource_object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "permissionship", kind: "enum", T: proto3.getEnumType(LookupPermissionship) },
    { no: 4, name: "partial_caveat_info", kind: "message", T: PartialCaveatInfo },
    { no: 5, name: "after_result_cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupResourcesResponse {
    return new LookupResourcesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupResourcesResponse {
    return new LookupResourcesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupResourcesResponse {
    return new LookupResourcesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LookupResourcesResponse | PlainMessage<LookupResourcesResponse> | undefined, b: LookupResourcesResponse | PlainMessage<LookupResourcesResponse> | undefined): boolean {
    return proto3.util.equals(LookupResourcesResponse, a, b);
  }
}

/**
 * LookupSubjectsRequest performs a lookup of all subjects of a particular
 * kind for which the subject has the specified permission or the relation in
 * which the subject exists, streaming back the IDs of those subjects.
 *
 * @generated from message authzed.api.v1.LookupSubjectsRequest
 */
export class LookupSubjectsRequest extends Message<LookupSubjectsRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * resource is the resource for which all matching subjects for the permission
   * or relation will be returned.
   *
   * @generated from field: authzed.api.v1.ObjectReference resource = 2;
   */
  resource?: ObjectReference;

  /**
   * permission is the name of the permission (or relation) for which to find
   * the subjects.
   *
   * @generated from field: string permission = 3;
   */
  permission = "";

  /**
   * subject_object_type is the type of subject object for which the IDs will
   * be returned.
   *
   * @generated from field: string subject_object_type = 4;
   */
  subjectObjectType = "";

  /**
   * optional_subject_relation is the optional relation for the subject.
   *
   * @generated from field: string optional_subject_relation = 5;
   */
  optionalSubjectRelation = "";

  /**
   * context consists of named values that are injected into the caveat evaluation context
   *
   * @generated from field: google.protobuf.Struct context = 6;
   */
  context?: Struct;

  /**
   * optional_concrete_limit, if non-zero, specifies the limit on the number of
   * *concrete* (non-wildcard) subjects to return before the stream is closed on the
   * server side. With the default value of zero, the stream will continue resolving
   * concrete subjects until exhausted or the stream is closed due to the client or
   * a network issue.
   *
   * NOTE: Wildcard subjects ("*") have special treatment when cursors and limits are used. Because
   * wildcards can apply to *any* concrete subjects, if a wildcard subject is found within the dataset,
   * a wildcard subject can be returned for *all* LookupSubjects calls, regardless of the cursor or
   * limit.
   *
   * For example, if wildcards are requested, a wildcard subject exists, there is a specified limit
   * of 10 concrete subjects, and at least 10 concrete subjects exist, the API will return 11 subjects
   * in total: the 10 concrete + the wildcard
   *
   * Furthermore, if a wildcard has a set of exclusions generated by the dataset,
   * the exclusions *will respect the cursor* and only a *partial* set of exclusions will be returned
   * for each invocation of the API.
   *
   * ***IT IS UP TO THE CALLER IN THIS CASE TO COMBINE THE EXCLUSIONS IF DESIRED***
   *
   * @generated from field: uint32 optional_concrete_limit = 7;
   */
  optionalConcreteLimit = 0;

  /**
   * optional_cursor, if specified, indicates the cursor after which results should resume being returned.
   * The cursor can be found on the LookupSubjectsResponse object.
   *
   * NOTE: See above for notes about how cursors interact with wildcard subjects.
   *
   * @generated from field: authzed.api.v1.Cursor optional_cursor = 8;
   */
  optionalCursor?: Cursor;

  /**
   * wildcard_option specifies whether wildcards should be returned by LookupSubjects.
   * For backwards compatibility, defaults to WILDCARD_OPTION_INCLUDE_WILDCARDS if unspecified.
   *
   * @generated from field: authzed.api.v1.LookupSubjectsRequest.WildcardOption wildcard_option = 9;
   */
  wildcardOption = LookupSubjectsRequest_WildcardOption.UNSPECIFIED;

  constructor(data?: PartialMessage<LookupSubjectsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.LookupSubjectsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "resource", kind: "message", T: ObjectReference },
    { no: 3, name: "permission", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "subject_object_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "optional_subject_relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "context", kind: "message", T: Struct },
    { no: 7, name: "optional_concrete_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "optional_cursor", kind: "message", T: Cursor },
    { no: 9, name: "wildcard_option", kind: "enum", T: proto3.getEnumType(LookupSubjectsRequest_WildcardOption) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupSubjectsRequest {
    return new LookupSubjectsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupSubjectsRequest {
    return new LookupSubjectsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupSubjectsRequest {
    return new LookupSubjectsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LookupSubjectsRequest | PlainMessage<LookupSubjectsRequest> | undefined, b: LookupSubjectsRequest | PlainMessage<LookupSubjectsRequest> | undefined): boolean {
    return proto3.util.equals(LookupSubjectsRequest, a, b);
  }
}

/**
 * @generated from enum authzed.api.v1.LookupSubjectsRequest.WildcardOption
 */
export enum LookupSubjectsRequest_WildcardOption {
  /**
   * @generated from enum value: WILDCARD_OPTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: WILDCARD_OPTION_INCLUDE_WILDCARDS = 1;
   */
  INCLUDE_WILDCARDS = 1,

  /**
   * @generated from enum value: WILDCARD_OPTION_EXCLUDE_WILDCARDS = 2;
   */
  EXCLUDE_WILDCARDS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LookupSubjectsRequest_WildcardOption)
proto3.util.setEnumType(LookupSubjectsRequest_WildcardOption, "authzed.api.v1.LookupSubjectsRequest.WildcardOption", [
  { no: 0, name: "WILDCARD_OPTION_UNSPECIFIED" },
  { no: 1, name: "WILDCARD_OPTION_INCLUDE_WILDCARDS" },
  { no: 2, name: "WILDCARD_OPTION_EXCLUDE_WILDCARDS" },
]);

/**
 * LookupSubjectsResponse contains a single matching subject object ID for the
 * requested subject object type on the permission or relation.
 *
 * @generated from message authzed.api.v1.LookupSubjectsResponse
 */
export class LookupSubjectsResponse extends Message<LookupSubjectsResponse> {
  /**
   * @generated from field: authzed.api.v1.ZedToken looked_up_at = 1;
   */
  lookedUpAt?: ZedToken;

  /**
   * subject_object_id is the Object ID of the subject found. May be a `*` if
   * a wildcard was found.
   * deprecated: use `subject`
   *
   * @generated from field: string subject_object_id = 2 [deprecated = true];
   * @deprecated
   */
  subjectObjectId = "";

  /**
   * excluded_subject_ids are the Object IDs of the subjects excluded. This list
   * will only contain object IDs if `subject_object_id` is a wildcard (`*`) and
   * will only be populated if exclusions exist from the wildcard.
   * deprecated: use `excluded_subjects`
   *
   * @generated from field: repeated string excluded_subject_ids = 3 [deprecated = true];
   * @deprecated
   */
  excludedSubjectIds: string[] = [];

  /**
   * permissionship indicates whether the response was partially evaluated or not
   * deprecated: use `subject.permissionship`
   *
   * @generated from field: authzed.api.v1.LookupPermissionship permissionship = 4 [deprecated = true];
   * @deprecated
   */
  permissionship = LookupPermissionship.UNSPECIFIED;

  /**
   * partial_caveat_info holds information of a partially-evaluated caveated response
   * deprecated: use `subject.partial_caveat_info`
   *
   * @generated from field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 5 [deprecated = true];
   * @deprecated
   */
  partialCaveatInfo?: PartialCaveatInfo;

  /**
   * subject is the subject found, along with its permissionship.
   *
   * @generated from field: authzed.api.v1.ResolvedSubject subject = 6;
   */
  subject?: ResolvedSubject;

  /**
   * excluded_subjects are the subjects excluded. This list
   * will only contain subjects if `subject.subject_object_id` is a wildcard (`*`) and
   * will only be populated if exclusions exist from the wildcard.
   *
   * @generated from field: repeated authzed.api.v1.ResolvedSubject excluded_subjects = 7;
   */
  excludedSubjects: ResolvedSubject[] = [];

  /**
   * after_result_cursor holds a cursor that can be used to resume the LookupSubjects stream after this
   * result.
   *
   * @generated from field: authzed.api.v1.Cursor after_result_cursor = 8;
   */
  afterResultCursor?: Cursor;

  constructor(data?: PartialMessage<LookupSubjectsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.LookupSubjectsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "looked_up_at", kind: "message", T: ZedToken },
    { no: 2, name: "subject_object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "excluded_subject_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "permissionship", kind: "enum", T: proto3.getEnumType(LookupPermissionship) },
    { no: 5, name: "partial_caveat_info", kind: "message", T: PartialCaveatInfo },
    { no: 6, name: "subject", kind: "message", T: ResolvedSubject },
    { no: 7, name: "excluded_subjects", kind: "message", T: ResolvedSubject, repeated: true },
    { no: 8, name: "after_result_cursor", kind: "message", T: Cursor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupSubjectsResponse {
    return new LookupSubjectsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupSubjectsResponse {
    return new LookupSubjectsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupSubjectsResponse {
    return new LookupSubjectsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LookupSubjectsResponse | PlainMessage<LookupSubjectsResponse> | undefined, b: LookupSubjectsResponse | PlainMessage<LookupSubjectsResponse> | undefined): boolean {
    return proto3.util.equals(LookupSubjectsResponse, a, b);
  }
}

/**
 * ResolvedSubject is a single subject resolved within LookupSubjects.
 *
 * @generated from message authzed.api.v1.ResolvedSubject
 */
export class ResolvedSubject extends Message<ResolvedSubject> {
  /**
   * subject_object_id is the Object ID of the subject found. May be a `*` if
   * a wildcard was found.
   *
   * @generated from field: string subject_object_id = 1;
   */
  subjectObjectId = "";

  /**
   * permissionship indicates whether the response was partially evaluated or not
   *
   * @generated from field: authzed.api.v1.LookupPermissionship permissionship = 2;
   */
  permissionship = LookupPermissionship.UNSPECIFIED;

  /**
   * partial_caveat_info holds information of a partially-evaluated caveated response
   *
   * @generated from field: authzed.api.v1.PartialCaveatInfo partial_caveat_info = 3;
   */
  partialCaveatInfo?: PartialCaveatInfo;

  constructor(data?: PartialMessage<ResolvedSubject>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ResolvedSubject";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subject_object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "permissionship", kind: "enum", T: proto3.getEnumType(LookupPermissionship) },
    { no: 3, name: "partial_caveat_info", kind: "message", T: PartialCaveatInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResolvedSubject {
    return new ResolvedSubject().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResolvedSubject {
    return new ResolvedSubject().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResolvedSubject {
    return new ResolvedSubject().fromJsonString(jsonString, options);
  }

  static equals(a: ResolvedSubject | PlainMessage<ResolvedSubject> | undefined, b: ResolvedSubject | PlainMessage<ResolvedSubject> | undefined): boolean {
    return proto3.util.equals(ResolvedSubject, a, b);
  }
}

/**
 * ImportBulkRelationshipsRequest represents one batch of the streaming
 * ImportBulkRelationships API. The maximum size is only limited by the backing
 * datastore, and optimal size should be determined by the calling client
 * experimentally. When ImportBulk is invoked and receives its first request message,
 * a transaction is opened to import the relationships. All requests sent to the same
 * invocation are executed under this single transaction. If a relationship already
 * exists within the datastore, the entire transaction will fail with an error.
 *
 * @generated from message authzed.api.v1.ImportBulkRelationshipsRequest
 */
export class ImportBulkRelationshipsRequest extends Message<ImportBulkRelationshipsRequest> {
  /**
   * @generated from field: repeated authzed.api.v1.Relationship relationships = 1;
   */
  relationships: Relationship[] = [];

  constructor(data?: PartialMessage<ImportBulkRelationshipsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ImportBulkRelationshipsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "relationships", kind: "message", T: Relationship, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportBulkRelationshipsRequest {
    return new ImportBulkRelationshipsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportBulkRelationshipsRequest {
    return new ImportBulkRelationshipsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportBulkRelationshipsRequest {
    return new ImportBulkRelationshipsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ImportBulkRelationshipsRequest | PlainMessage<ImportBulkRelationshipsRequest> | undefined, b: ImportBulkRelationshipsRequest | PlainMessage<ImportBulkRelationshipsRequest> | undefined): boolean {
    return proto3.util.equals(ImportBulkRelationshipsRequest, a, b);
  }
}

/**
 * ImportBulkRelationshipsResponse is returned on successful completion of the
 * bulk load stream, and contains the total number of relationships loaded.
 *
 * @generated from message authzed.api.v1.ImportBulkRelationshipsResponse
 */
export class ImportBulkRelationshipsResponse extends Message<ImportBulkRelationshipsResponse> {
  /**
   * @generated from field: uint64 num_loaded = 1;
   */
  numLoaded = protoInt64.zero;

  constructor(data?: PartialMessage<ImportBulkRelationshipsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ImportBulkRelationshipsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_loaded", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportBulkRelationshipsResponse {
    return new ImportBulkRelationshipsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportBulkRelationshipsResponse {
    return new ImportBulkRelationshipsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportBulkRelationshipsResponse {
    return new ImportBulkRelationshipsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ImportBulkRelationshipsResponse | PlainMessage<ImportBulkRelationshipsResponse> | undefined, b: ImportBulkRelationshipsResponse | PlainMessage<ImportBulkRelationshipsResponse> | undefined): boolean {
    return proto3.util.equals(ImportBulkRelationshipsResponse, a, b);
  }
}

/**
 * ExportBulkRelationshipsRequest represents a resumable request for
 * all relationships from the server.
 *
 * @generated from message authzed.api.v1.ExportBulkRelationshipsRequest
 */
export class ExportBulkRelationshipsRequest extends Message<ExportBulkRelationshipsRequest> {
  /**
   * @generated from field: authzed.api.v1.Consistency consistency = 1;
   */
  consistency?: Consistency;

  /**
   * optional_limit, if non-zero, specifies the limit on the number of
   * relationships the server can return in one page. By default, the server
   * will pick a page size, and the server is free to choose a smaller size
   * at will.
   *
   * @generated from field: uint32 optional_limit = 2;
   */
  optionalLimit = 0;

  /**
   * optional_cursor, if specified, indicates the cursor after which results
   * should resume being returned. The cursor can be found on the
   * BulkExportRelationshipsResponse object.
   *
   * @generated from field: authzed.api.v1.Cursor optional_cursor = 3;
   */
  optionalCursor?: Cursor;

  /**
   * optional_relationship_filter, if specified, indicates the
   * filter to apply to each relationship to be exported.
   *
   * @generated from field: authzed.api.v1.RelationshipFilter optional_relationship_filter = 4;
   */
  optionalRelationshipFilter?: RelationshipFilter;

  constructor(data?: PartialMessage<ExportBulkRelationshipsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExportBulkRelationshipsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "consistency", kind: "message", T: Consistency },
    { no: 2, name: "optional_limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 3, name: "optional_cursor", kind: "message", T: Cursor },
    { no: 4, name: "optional_relationship_filter", kind: "message", T: RelationshipFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportBulkRelationshipsRequest {
    return new ExportBulkRelationshipsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportBulkRelationshipsRequest {
    return new ExportBulkRelationshipsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportBulkRelationshipsRequest {
    return new ExportBulkRelationshipsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExportBulkRelationshipsRequest | PlainMessage<ExportBulkRelationshipsRequest> | undefined, b: ExportBulkRelationshipsRequest | PlainMessage<ExportBulkRelationshipsRequest> | undefined): boolean {
    return proto3.util.equals(ExportBulkRelationshipsRequest, a, b);
  }
}

/**
 * ExportBulkRelationshipsResponse is one page in a stream of relationship
 * groups that meet the criteria specified by the originating request. The
 * server will continue to stream back relationship groups as quickly as it can
 * until all relationships have been transmitted back.
 *
 * @generated from message authzed.api.v1.ExportBulkRelationshipsResponse
 */
export class ExportBulkRelationshipsResponse extends Message<ExportBulkRelationshipsResponse> {
  /**
   * @generated from field: authzed.api.v1.Cursor after_result_cursor = 1;
   */
  afterResultCursor?: Cursor;

  /**
   * @generated from field: repeated authzed.api.v1.Relationship relationships = 2;
   */
  relationships: Relationship[] = [];

  constructor(data?: PartialMessage<ExportBulkRelationshipsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ExportBulkRelationshipsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "after_result_cursor", kind: "message", T: Cursor },
    { no: 2, name: "relationships", kind: "message", T: Relationship, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportBulkRelationshipsResponse {
    return new ExportBulkRelationshipsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportBulkRelationshipsResponse {
    return new ExportBulkRelationshipsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportBulkRelationshipsResponse {
    return new ExportBulkRelationshipsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExportBulkRelationshipsResponse | PlainMessage<ExportBulkRelationshipsResponse> | undefined, b: ExportBulkRelationshipsResponse | PlainMessage<ExportBulkRelationshipsResponse> | undefined): boolean {
    return proto3.util.equals(ExportBulkRelationshipsResponse, a, b);
  }
}

