// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file authzed/api/v1/core.proto (package authzed.api.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Struct } from "@bufbuild/protobuf";

/**
 * Relationship specifies how a resource relates to a subject. Relationships
 * form the data for the graph over which all permissions questions are
 * answered.
 *
 * @generated from message authzed.api.v1.Relationship
 */
export class Relationship extends Message<Relationship> {
  /**
   * resource is the resource to which the subject is related, in some manner
   *
   * @generated from field: authzed.api.v1.ObjectReference resource = 1;
   */
  resource?: ObjectReference;

  /**
   * relation is how the resource and subject are related.
   *
   * @generated from field: string relation = 2;
   */
  relation = "";

  /**
   * subject is the subject to which the resource is related, in some manner.
   *
   * @generated from field: authzed.api.v1.SubjectReference subject = 3;
   */
  subject?: SubjectReference;

  /**
   * optional_caveat is a reference to a the caveat that must be enforced over the relationship
   *
   * @generated from field: authzed.api.v1.ContextualizedCaveat optional_caveat = 4;
   */
  optionalCaveat?: ContextualizedCaveat;

  constructor(data?: PartialMessage<Relationship>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.Relationship";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource", kind: "message", T: ObjectReference },
    { no: 2, name: "relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "subject", kind: "message", T: SubjectReference },
    { no: 4, name: "optional_caveat", kind: "message", T: ContextualizedCaveat },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Relationship {
    return new Relationship().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Relationship {
    return new Relationship().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Relationship {
    return new Relationship().fromJsonString(jsonString, options);
  }

  static equals(a: Relationship | PlainMessage<Relationship> | undefined, b: Relationship | PlainMessage<Relationship> | undefined): boolean {
    return proto3.util.equals(Relationship, a, b);
  }
}

/**
 * ContextualizedCaveat represents a reference to a caveat to be used by caveated relationships.
 * The context consists of key-value pairs that will be injected at evaluation time.
 * The keys must match the arguments defined on the caveat in the schema.
 *
 * @generated from message authzed.api.v1.ContextualizedCaveat
 */
export class ContextualizedCaveat extends Message<ContextualizedCaveat> {
  /**
   * caveat_name is the name of the caveat expression to use, as defined in the schema
   *
   * @generated from field: string caveat_name = 1;
   */
  caveatName = "";

  /**
   * context consists of any named values that are defined at write time for the caveat expression
   *
   * @generated from field: google.protobuf.Struct context = 2;
   */
  context?: Struct;

  constructor(data?: PartialMessage<ContextualizedCaveat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ContextualizedCaveat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "caveat_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "context", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContextualizedCaveat {
    return new ContextualizedCaveat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContextualizedCaveat {
    return new ContextualizedCaveat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContextualizedCaveat {
    return new ContextualizedCaveat().fromJsonString(jsonString, options);
  }

  static equals(a: ContextualizedCaveat | PlainMessage<ContextualizedCaveat> | undefined, b: ContextualizedCaveat | PlainMessage<ContextualizedCaveat> | undefined): boolean {
    return proto3.util.equals(ContextualizedCaveat, a, b);
  }
}

/**
 * SubjectReference is used for referring to the subject portion of a
 * Relationship. The relation component is optional and is used for defining a
 * sub-relation on the subject, e.g. group:123#members
 *
 * @generated from message authzed.api.v1.SubjectReference
 */
export class SubjectReference extends Message<SubjectReference> {
  /**
   * @generated from field: authzed.api.v1.ObjectReference object = 1;
   */
  object?: ObjectReference;

  /**
   * @generated from field: string optional_relation = 2;
   */
  optionalRelation = "";

  constructor(data?: PartialMessage<SubjectReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.SubjectReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object", kind: "message", T: ObjectReference },
    { no: 2, name: "optional_relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SubjectReference {
    return new SubjectReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SubjectReference {
    return new SubjectReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SubjectReference {
    return new SubjectReference().fromJsonString(jsonString, options);
  }

  static equals(a: SubjectReference | PlainMessage<SubjectReference> | undefined, b: SubjectReference | PlainMessage<SubjectReference> | undefined): boolean {
    return proto3.util.equals(SubjectReference, a, b);
  }
}

/**
 * ObjectReference is used to refer to a specific object in the system.
 *
 * @generated from message authzed.api.v1.ObjectReference
 */
export class ObjectReference extends Message<ObjectReference> {
  /**
   * @generated from field: string object_type = 1;
   */
  objectType = "";

  /**
   * @generated from field: string object_id = 2;
   */
  objectId = "";

  constructor(data?: PartialMessage<ObjectReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ObjectReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "object_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "object_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ObjectReference {
    return new ObjectReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ObjectReference {
    return new ObjectReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ObjectReference {
    return new ObjectReference().fromJsonString(jsonString, options);
  }

  static equals(a: ObjectReference | PlainMessage<ObjectReference> | undefined, b: ObjectReference | PlainMessage<ObjectReference> | undefined): boolean {
    return proto3.util.equals(ObjectReference, a, b);
  }
}

/**
 * ZedToken is used to provide causality metadata between Write and Check
 * requests.
 *
 * See the authzed.api.v1.Consistency message for more information.
 *
 * @generated from message authzed.api.v1.ZedToken
 */
export class ZedToken extends Message<ZedToken> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<ZedToken>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.ZedToken";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ZedToken {
    return new ZedToken().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ZedToken {
    return new ZedToken().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ZedToken {
    return new ZedToken().fromJsonString(jsonString, options);
  }

  static equals(a: ZedToken | PlainMessage<ZedToken> | undefined, b: ZedToken | PlainMessage<ZedToken> | undefined): boolean {
    return proto3.util.equals(ZedToken, a, b);
  }
}

/**
 * Cursor is used to provide resumption of listing between calls to APIs
 * such as LookupResources.
 *
 * @generated from message authzed.api.v1.Cursor
 */
export class Cursor extends Message<Cursor> {
  /**
   * @generated from field: string token = 1;
   */
  token = "";

  constructor(data?: PartialMessage<Cursor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.Cursor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cursor {
    return new Cursor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cursor {
    return new Cursor().fromJsonString(jsonString, options);
  }

  static equals(a: Cursor | PlainMessage<Cursor> | undefined, b: Cursor | PlainMessage<Cursor> | undefined): boolean {
    return proto3.util.equals(Cursor, a, b);
  }
}

/**
 * RelationshipUpdate is used for mutating a single relationship within the
 * service.
 *
 * CREATE will create the relationship only if it doesn't exist, and error
 * otherwise.
 *
 * TOUCH will upsert the relationship, and will not error if it
 * already exists.
 *
 * DELETE will delete the relationship. If the relationship does not exist,
 * this operation will no-op.
 *
 * @generated from message authzed.api.v1.RelationshipUpdate
 */
export class RelationshipUpdate extends Message<RelationshipUpdate> {
  /**
   * @generated from field: authzed.api.v1.RelationshipUpdate.Operation operation = 1;
   */
  operation = RelationshipUpdate_Operation.UNSPECIFIED;

  /**
   * @generated from field: authzed.api.v1.Relationship relationship = 2;
   */
  relationship?: Relationship;

  constructor(data?: PartialMessage<RelationshipUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.RelationshipUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation", kind: "enum", T: proto3.getEnumType(RelationshipUpdate_Operation) },
    { no: 2, name: "relationship", kind: "message", T: Relationship },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipUpdate {
    return new RelationshipUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipUpdate {
    return new RelationshipUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipUpdate {
    return new RelationshipUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipUpdate | PlainMessage<RelationshipUpdate> | undefined, b: RelationshipUpdate | PlainMessage<RelationshipUpdate> | undefined): boolean {
    return proto3.util.equals(RelationshipUpdate, a, b);
  }
}

/**
 * @generated from enum authzed.api.v1.RelationshipUpdate.Operation
 */
export enum RelationshipUpdate_Operation {
  /**
   * @generated from enum value: OPERATION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OPERATION_CREATE = 1;
   */
  CREATE = 1,

  /**
   * @generated from enum value: OPERATION_TOUCH = 2;
   */
  TOUCH = 2,

  /**
   * @generated from enum value: OPERATION_DELETE = 3;
   */
  DELETE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(RelationshipUpdate_Operation)
proto3.util.setEnumType(RelationshipUpdate_Operation, "authzed.api.v1.RelationshipUpdate.Operation", [
  { no: 0, name: "OPERATION_UNSPECIFIED" },
  { no: 1, name: "OPERATION_CREATE" },
  { no: 2, name: "OPERATION_TOUCH" },
  { no: 3, name: "OPERATION_DELETE" },
]);

/**
 * PermissionRelationshipTree is used for representing a tree of a resource and
 * its permission relationships with other objects.
 *
 * @generated from message authzed.api.v1.PermissionRelationshipTree
 */
export class PermissionRelationshipTree extends Message<PermissionRelationshipTree> {
  /**
   * @generated from oneof authzed.api.v1.PermissionRelationshipTree.tree_type
   */
  treeType: {
    /**
     * @generated from field: authzed.api.v1.AlgebraicSubjectSet intermediate = 1;
     */
    value: AlgebraicSubjectSet;
    case: "intermediate";
  } | {
    /**
     * @generated from field: authzed.api.v1.DirectSubjectSet leaf = 2;
     */
    value: DirectSubjectSet;
    case: "leaf";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: authzed.api.v1.ObjectReference expanded_object = 3;
   */
  expandedObject?: ObjectReference;

  /**
   * @generated from field: string expanded_relation = 4;
   */
  expandedRelation = "";

  constructor(data?: PartialMessage<PermissionRelationshipTree>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.PermissionRelationshipTree";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "intermediate", kind: "message", T: AlgebraicSubjectSet, oneof: "tree_type" },
    { no: 2, name: "leaf", kind: "message", T: DirectSubjectSet, oneof: "tree_type" },
    { no: 3, name: "expanded_object", kind: "message", T: ObjectReference },
    { no: 4, name: "expanded_relation", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PermissionRelationshipTree {
    return new PermissionRelationshipTree().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PermissionRelationshipTree {
    return new PermissionRelationshipTree().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PermissionRelationshipTree {
    return new PermissionRelationshipTree().fromJsonString(jsonString, options);
  }

  static equals(a: PermissionRelationshipTree | PlainMessage<PermissionRelationshipTree> | undefined, b: PermissionRelationshipTree | PlainMessage<PermissionRelationshipTree> | undefined): boolean {
    return proto3.util.equals(PermissionRelationshipTree, a, b);
  }
}

/**
 * AlgebraicSubjectSet is a subject set which is computed based on applying the
 * specified operation to the operands according to the algebra of sets.
 *
 * UNION is a logical set containing the subject members from all operands.
 *
 * INTERSECTION is a logical set containing only the subject members which are
 * present in all operands.
 *
 * EXCLUSION is a logical set containing only the subject members which are
 * present in the first operand, and none of the other operands.
 *
 * @generated from message authzed.api.v1.AlgebraicSubjectSet
 */
export class AlgebraicSubjectSet extends Message<AlgebraicSubjectSet> {
  /**
   * @generated from field: authzed.api.v1.AlgebraicSubjectSet.Operation operation = 1;
   */
  operation = AlgebraicSubjectSet_Operation.UNSPECIFIED;

  /**
   * @generated from field: repeated authzed.api.v1.PermissionRelationshipTree children = 2;
   */
  children: PermissionRelationshipTree[] = [];

  constructor(data?: PartialMessage<AlgebraicSubjectSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.AlgebraicSubjectSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operation", kind: "enum", T: proto3.getEnumType(AlgebraicSubjectSet_Operation) },
    { no: 2, name: "children", kind: "message", T: PermissionRelationshipTree, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AlgebraicSubjectSet {
    return new AlgebraicSubjectSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AlgebraicSubjectSet {
    return new AlgebraicSubjectSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AlgebraicSubjectSet {
    return new AlgebraicSubjectSet().fromJsonString(jsonString, options);
  }

  static equals(a: AlgebraicSubjectSet | PlainMessage<AlgebraicSubjectSet> | undefined, b: AlgebraicSubjectSet | PlainMessage<AlgebraicSubjectSet> | undefined): boolean {
    return proto3.util.equals(AlgebraicSubjectSet, a, b);
  }
}

/**
 * @generated from enum authzed.api.v1.AlgebraicSubjectSet.Operation
 */
export enum AlgebraicSubjectSet_Operation {
  /**
   * @generated from enum value: OPERATION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OPERATION_UNION = 1;
   */
  UNION = 1,

  /**
   * @generated from enum value: OPERATION_INTERSECTION = 2;
   */
  INTERSECTION = 2,

  /**
   * @generated from enum value: OPERATION_EXCLUSION = 3;
   */
  EXCLUSION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(AlgebraicSubjectSet_Operation)
proto3.util.setEnumType(AlgebraicSubjectSet_Operation, "authzed.api.v1.AlgebraicSubjectSet.Operation", [
  { no: 0, name: "OPERATION_UNSPECIFIED" },
  { no: 1, name: "OPERATION_UNION" },
  { no: 2, name: "OPERATION_INTERSECTION" },
  { no: 3, name: "OPERATION_EXCLUSION" },
]);

/**
 * DirectSubjectSet is a subject set which is simply a collection of subjects.
 *
 * @generated from message authzed.api.v1.DirectSubjectSet
 */
export class DirectSubjectSet extends Message<DirectSubjectSet> {
  /**
   * @generated from field: repeated authzed.api.v1.SubjectReference subjects = 1;
   */
  subjects: SubjectReference[] = [];

  constructor(data?: PartialMessage<DirectSubjectSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.DirectSubjectSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subjects", kind: "message", T: SubjectReference, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DirectSubjectSet {
    return new DirectSubjectSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DirectSubjectSet {
    return new DirectSubjectSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DirectSubjectSet {
    return new DirectSubjectSet().fromJsonString(jsonString, options);
  }

  static equals(a: DirectSubjectSet | PlainMessage<DirectSubjectSet> | undefined, b: DirectSubjectSet | PlainMessage<DirectSubjectSet> | undefined): boolean {
    return proto3.util.equals(DirectSubjectSet, a, b);
  }
}

/**
 * PartialCaveatInfo carries information necessary for the client to take action
 * in the event a response contains a partially evaluated caveat
 *
 * @generated from message authzed.api.v1.PartialCaveatInfo
 */
export class PartialCaveatInfo extends Message<PartialCaveatInfo> {
  /**
   * missing_required_context is a list of one or more fields that were missing and prevented caveats
   * from being fully evaluated
   *
   * @generated from field: repeated string missing_required_context = 1;
   */
  missingRequiredContext: string[] = [];

  constructor(data?: PartialMessage<PartialCaveatInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "authzed.api.v1.PartialCaveatInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "missing_required_context", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PartialCaveatInfo {
    return new PartialCaveatInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PartialCaveatInfo {
    return new PartialCaveatInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PartialCaveatInfo {
    return new PartialCaveatInfo().fromJsonString(jsonString, options);
  }

  static equals(a: PartialCaveatInfo | PlainMessage<PartialCaveatInfo> | undefined, b: PartialCaveatInfo | PlainMessage<PartialCaveatInfo> | undefined): boolean {
    return proto3.util.equals(PartialCaveatInfo, a, b);
  }
}

